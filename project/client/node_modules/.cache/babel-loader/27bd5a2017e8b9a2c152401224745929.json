{"ast":null,"code":"/*!\nFullCalendar Day Grid Plugin v4.4.0\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\nimport { addWeeks, diffWeeks, DateProfileGenerator, createElement, listenBySelector, removeElement, computeRect, computeClippingRect, applyStyle, computeEventDraggable, computeEventStartResizable, computeEventEndResizable, cssToStr, htmlEscape, FgEventRenderer, appendToElement, prependToElement, htmlToElement, FillRenderer, memoizeRendering, createFormatter, addDays, DateComponent, rangeContainsMarker, getDayClasses, findElements, PositionCache, buildGotoAnchorHtml, findChildren, insertAfterElement, intersectRanges, memoize, ScrollComponent, matchCellWidths, uncompensateScroll, compensateScroll, subtractInnerElHeight, distributeHeight, undistributeHeight, View, Slicer, DayHeader, DaySeries, DayTable, createPlugin } from '@fullcalendar/core';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nvar DayGridDateProfileGenerator =\n/** @class */\nfunction (_super) {\n  __extends(DayGridDateProfileGenerator, _super);\n\n  function DayGridDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  DayGridDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = addWeeks(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.options.monthMode && this.options.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      diffWeeks(start, end));\n      end = addWeeks(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return DayGridDateProfileGenerator;\n}(DateProfileGenerator);\n/* A rectangular panel that is absolutely positioned over other content\n------------------------------------------------------------------------------------------------------------------------\nOptions:\n  - className (string)\n  - content (HTML string, element, or element array)\n  - parentEl\n  - top\n  - left\n  - right (the x coord of where the right edge should be. not a \"CSS\" right)\n  - autoHide (boolean)\n  - show (callback)\n  - hide (callback)\n*/\n\n\nvar Popover =\n/** @class */\nfunction () {\n  function Popover(options) {\n    var _this = this;\n\n    this.isHidden = true;\n    this.margin = 10; // the space required between the popover and the edges of the scroll container\n    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n    this.documentMousedown = function (ev) {\n      // only hide the popover if the click happened outside the popover\n      if (_this.el && !_this.el.contains(ev.target)) {\n        _this.hide();\n      }\n    };\n\n    this.options = options;\n  } // Shows the popover on the specified position. Renders it if not already\n\n\n  Popover.prototype.show = function () {\n    if (this.isHidden) {\n      if (!this.el) {\n        this.render();\n      }\n\n      this.el.style.display = '';\n      this.position();\n      this.isHidden = false;\n      this.trigger('show');\n    }\n  }; // Hides the popover, through CSS, but does not remove it from the DOM\n\n\n  Popover.prototype.hide = function () {\n    if (!this.isHidden) {\n      this.el.style.display = 'none';\n      this.isHidden = true;\n      this.trigger('hide');\n    }\n  }; // Creates `this.el` and renders content inside of it\n\n\n  Popover.prototype.render = function () {\n    var _this = this;\n\n    var options = this.options;\n    var el = this.el = createElement('div', {\n      className: 'fc-popover ' + (options.className || ''),\n      style: {\n        top: '0',\n        left: '0'\n      }\n    });\n\n    if (typeof options.content === 'function') {\n      options.content(el);\n    }\n\n    options.parentEl.appendChild(el); // when a click happens on anything inside with a 'fc-close' className, hide the popover\n\n    listenBySelector(el, 'click', '.fc-close', function (ev) {\n      _this.hide();\n    });\n\n    if (options.autoHide) {\n      document.addEventListener('mousedown', this.documentMousedown);\n    }\n  }; // Hides and unregisters any handlers\n\n\n  Popover.prototype.destroy = function () {\n    this.hide();\n\n    if (this.el) {\n      removeElement(this.el);\n      this.el = null;\n    }\n\n    document.removeEventListener('mousedown', this.documentMousedown);\n  }; // Positions the popover optimally, using the top/left/right options\n\n\n  Popover.prototype.position = function () {\n    var options = this.options;\n    var el = this.el;\n    var elDims = el.getBoundingClientRect(); // only used for width,height\n\n    var origin = computeRect(el.offsetParent);\n    var clippingRect = computeClippingRect(options.parentEl);\n    var top; // the \"position\" (not \"offset\") values for the popover\n\n    var left; //\n    // compute top and left\n\n    top = options.top || 0;\n\n    if (options.left !== undefined) {\n      left = options.left;\n    } else if (options.right !== undefined) {\n      left = options.right - elDims.width; // derive the left value from the right value\n    } else {\n      left = 0;\n    } // constrain to the view port. if constrained by two edges, give precedence to top/left\n\n\n    top = Math.min(top, clippingRect.bottom - elDims.height - this.margin);\n    top = Math.max(top, clippingRect.top + this.margin);\n    left = Math.min(left, clippingRect.right - elDims.width - this.margin);\n    left = Math.max(left, clippingRect.left + this.margin);\n    applyStyle(el, {\n      top: top - origin.top,\n      left: left - origin.left\n    });\n  }; // Triggers a callback. Calls a function in the option hash of the same name.\n  // Arguments beyond the first `name` are forwarded on.\n  // TODO: better code reuse for this. Repeat code\n  // can kill this???\n\n\n  Popover.prototype.trigger = function (name) {\n    if (this.options[name]) {\n      this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  return Popover;\n}();\n/* Event-rendering methods for the DayGrid class\n----------------------------------------------------------------------------------------------------------------------*/\n// \"Simple\" is bad a name. has nothing to do with SimpleDayGrid\n\n\nvar SimpleDayGridEventRenderer =\n/** @class */\nfunction (_super) {\n  __extends(SimpleDayGridEventRenderer, _super);\n\n  function SimpleDayGridEventRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Builds the HTML to be used for the default element for an individual segment\n\n\n  SimpleDayGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {\n    var context = this.context;\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var eventUi = eventRange.ui;\n    var allDay = eventDef.allDay;\n    var isDraggable = computeEventDraggable(context, eventDef, eventUi);\n    var isResizableFromStart = allDay && seg.isStart && computeEventStartResizable(context, eventDef, eventUi);\n    var isResizableFromEnd = allDay && seg.isEnd && computeEventEndResizable(context, eventDef, eventUi);\n    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);\n    var skinCss = cssToStr(this.getSkinCss(eventUi));\n    var timeHtml = '';\n    var timeText;\n    var titleHtml;\n    classes.unshift('fc-day-grid-event', 'fc-h-event'); // Only display a timed events time if it is the starting segment\n\n    if (seg.isStart) {\n      timeText = this.getTimeText(eventRange);\n\n      if (timeText) {\n        timeHtml = '<span class=\"fc-time\">' + htmlEscape(timeText) + '</span>';\n      }\n    }\n\n    titleHtml = '<span class=\"fc-title\">' + (htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height\n    '</span>';\n    return '<a class=\"' + classes.join(' ') + '\"' + (eventDef.url ? ' href=\"' + htmlEscape(eventDef.url) + '\"' : '') + (skinCss ? ' style=\"' + skinCss + '\"' : '') + '>' + '<div class=\"fc-content\">' + (context.options.dir === 'rtl' ? titleHtml + ' ' + timeHtml : // put a natural space in between\n    timeHtml + ' ' + titleHtml //\n    ) + '</div>' + (isResizableFromStart ? '<div class=\"fc-resizer fc-start-resizer\"></div>' : '') + (isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\"></div>' : '') + '</a>';\n  }; // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined\n\n\n  SimpleDayGridEventRenderer.prototype.computeEventTimeFormat = function () {\n    return {\n      hour: 'numeric',\n      minute: '2-digit',\n      omitZeroMinute: true,\n      meridiem: 'narrow'\n    };\n  };\n\n  SimpleDayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n    return false; // TODO: somehow consider the originating DayGrid's column count\n  };\n\n  return SimpleDayGridEventRenderer;\n}(FgEventRenderer);\n/* Event-rendering methods for the DayGrid class\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nvar DayGridEventRenderer =\n/** @class */\nfunction (_super) {\n  __extends(DayGridEventRenderer, _super);\n\n  function DayGridEventRenderer(dayGrid) {\n    var _this = _super.call(this) || this;\n\n    _this.dayGrid = dayGrid;\n    return _this;\n  } // Renders the given foreground event segments onto the grid\n\n\n  DayGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    var rowStructs = this.rowStructs = this.renderSegRows(segs); // append to each row's content skeleton\n\n    this.dayGrid.rowEls.forEach(function (rowNode, i) {\n      rowNode.querySelector('.fc-content-skeleton > table').appendChild(rowStructs[i].tbodyEl);\n    }); // removes the \"more..\" events popover\n\n    if (!mirrorInfo) {\n      this.dayGrid.removeSegPopover();\n    }\n  }; // Unrenders all currently rendered foreground event segments\n\n\n  DayGridEventRenderer.prototype.detachSegs = function () {\n    var rowStructs = this.rowStructs || [];\n    var rowStruct;\n\n    while (rowStruct = rowStructs.pop()) {\n      removeElement(rowStruct.tbodyEl);\n    }\n\n    this.rowStructs = null;\n  }; // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n  // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n  // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n\n\n  DayGridEventRenderer.prototype.renderSegRows = function (segs) {\n    var rowStructs = [];\n    var segRows;\n    var row;\n    segRows = this.groupSegRows(segs); // group into nested arrays\n    // iterate each row of segment groupings\n\n    for (row = 0; row < segRows.length; row++) {\n      rowStructs.push(this.renderSegRow(row, segRows[row]));\n    }\n\n    return rowStructs;\n  }; // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n  // the segments. Returns object with a bunch of internal data about how the render was calculated.\n  // NOTE: modifies rowSegs\n\n\n  DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {\n    var isRtl = this.context.isRtl;\n    var dayGrid = this.dayGrid;\n    var colCnt = dayGrid.colCnt;\n    var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n\n    var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n\n    var tbody = document.createElement('tbody');\n    var segMatrix = []; // lookup for which segments are rendered into which level+col cells\n\n    var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n\n    var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n\n    var i;\n    var levelSegs;\n    var col;\n    var tr;\n    var j;\n    var seg;\n    var td; // populates empty cells from the current column (`col`) to `endCol`\n\n    function emptyCellsUntil(endCol) {\n      while (col < endCol) {\n        // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n        td = (loneCellMatrix[i - 1] || [])[col];\n\n        if (td) {\n          td.rowSpan = (td.rowSpan || 1) + 1;\n        } else {\n          td = document.createElement('td');\n          tr.appendChild(td);\n        }\n\n        cellMatrix[i][col] = td;\n        loneCellMatrix[i][col] = td;\n        col++;\n      }\n    }\n\n    for (i = 0; i < levelCnt; i++) {\n      // iterate through all levels\n      levelSegs = segLevels[i];\n      col = 0;\n      tr = document.createElement('tr');\n      segMatrix.push([]);\n      cellMatrix.push([]);\n      loneCellMatrix.push([]); // levelCnt might be 1 even though there are no actual levels. protect against this.\n      // this single empty row is useful for styling.\n\n      if (levelSegs) {\n        for (j = 0; j < levelSegs.length; j++) {\n          // iterate through segments in level\n          seg = levelSegs[j];\n          var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;\n          var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;\n          emptyCellsUntil(leftCol); // create a container that occupies or more columns. append the event element.\n\n          td = createElement('td', {\n            className: 'fc-event-container'\n          }, seg.el);\n\n          if (leftCol !== rightCol) {\n            td.colSpan = rightCol - leftCol + 1;\n          } else {\n            // a single-column segment\n            loneCellMatrix[i][col] = td;\n          }\n\n          while (col <= rightCol) {\n            cellMatrix[i][col] = td;\n            segMatrix[i][col] = seg;\n            col++;\n          }\n\n          tr.appendChild(td);\n        }\n      }\n\n      emptyCellsUntil(colCnt); // finish off the row\n\n      var introHtml = dayGrid.renderProps.renderIntroHtml();\n\n      if (introHtml) {\n        if (isRtl) {\n          appendToElement(tr, introHtml);\n        } else {\n          prependToElement(tr, introHtml);\n        }\n      }\n\n      tbody.appendChild(tr);\n    }\n\n    return {\n      row: row,\n      tbodyEl: tbody,\n      cellMatrix: cellMatrix,\n      segMatrix: segMatrix,\n      segLevels: segLevels,\n      segs: rowSegs\n    };\n  }; // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n  // NOTE: modifies segs\n\n\n  DayGridEventRenderer.prototype.buildSegLevels = function (segs) {\n    var isRtl = this.context.isRtl;\n    var colCnt = this.dayGrid.colCnt;\n    var levels = [];\n    var i;\n    var seg;\n    var j; // Give preference to elements with certain criteria, so they have\n    // a chance to be closer to the top.\n\n    segs = this.sortEventSegs(segs);\n\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i]; // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n\n      for (j = 0; j < levels.length; j++) {\n        if (!isDaySegCollision(seg, levels[j])) {\n          break;\n        }\n      } // `j` now holds the desired subrow index\n\n\n      seg.level = j;\n      seg.leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol; // for sorting only\n\n      seg.rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol // for sorting only\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    } // order segments left-to-right. very important if calendar is RTL\n\n\n    for (j = 0; j < levels.length; j++) {\n      levels[j].sort(compareDaySegCols);\n    }\n\n    return levels;\n  }; // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n\n\n  DayGridEventRenderer.prototype.groupSegRows = function (segs) {\n    var segRows = [];\n    var i;\n\n    for (i = 0; i < this.dayGrid.rowCnt; i++) {\n      segRows.push([]);\n    }\n\n    for (i = 0; i < segs.length; i++) {\n      segRows[segs[i].row].push(segs[i]);\n    }\n\n    return segRows;\n  }; // Computes a default `displayEventEnd` value if one is not expliclty defined\n\n\n  DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n    return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\n  };\n\n  return DayGridEventRenderer;\n}(SimpleDayGridEventRenderer); // Computes whether two segments' columns collide. They are assumed to be in the same row.\n\n\nfunction isDaySegCollision(seg, otherSegs) {\n  var i;\n  var otherSeg;\n\n  for (i = 0; i < otherSegs.length; i++) {\n    otherSeg = otherSegs[i];\n\n    if (otherSeg.firstCol <= seg.lastCol && otherSeg.lastCol >= seg.firstCol) {\n      return true;\n    }\n  }\n\n  return false;\n} // A cmp function for determining the leftmost event\n\n\nfunction compareDaySegCols(a, b) {\n  return a.leftCol - b.leftCol;\n}\n\nvar DayGridMirrorRenderer =\n/** @class */\nfunction (_super) {\n  __extends(DayGridMirrorRenderer, _super);\n\n  function DayGridMirrorRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    var sourceSeg = mirrorInfo.sourceSeg;\n    var rowStructs = this.rowStructs = this.renderSegRows(segs); // inject each new event skeleton into each associated row\n\n    this.dayGrid.rowEls.forEach(function (rowNode, row) {\n      var skeletonEl = htmlToElement('<div class=\"fc-mirror-skeleton\"><table></table></div>'); // will be absolutely positioned\n\n      var skeletonTopEl;\n      var skeletonTop; // If there is an original segment, match the top position. Otherwise, put it at the row's top level\n\n      if (sourceSeg && sourceSeg.row === row) {\n        skeletonTopEl = sourceSeg.el;\n      } else {\n        skeletonTopEl = rowNode.querySelector('.fc-content-skeleton tbody');\n\n        if (!skeletonTopEl) {\n          // when no events\n          skeletonTopEl = rowNode.querySelector('.fc-content-skeleton table');\n        }\n      }\n\n      skeletonTop = skeletonTopEl.getBoundingClientRect().top - rowNode.getBoundingClientRect().top; // the offsetParent origin\n\n      skeletonEl.style.top = skeletonTop + 'px';\n      skeletonEl.querySelector('table').appendChild(rowStructs[row].tbodyEl);\n      rowNode.appendChild(skeletonEl);\n    });\n  };\n\n  return DayGridMirrorRenderer;\n}(DayGridEventRenderer);\n\nvar EMPTY_CELL_HTML = '<td style=\"pointer-events:none\"></td>';\n\nvar DayGridFillRenderer =\n/** @class */\nfunction (_super) {\n  __extends(DayGridFillRenderer, _super);\n\n  function DayGridFillRenderer(dayGrid) {\n    var _this = _super.call(this) || this;\n\n    _this.fillSegTag = 'td'; // override the default tag name\n\n    _this.dayGrid = dayGrid;\n    return _this;\n  }\n\n  DayGridFillRenderer.prototype.renderSegs = function (type, context, segs) {\n    // don't render timed background events\n    if (type === 'bgEvent') {\n      segs = segs.filter(function (seg) {\n        return seg.eventRange.def.allDay;\n      });\n    }\n\n    _super.prototype.renderSegs.call(this, type, context, segs);\n  };\n\n  DayGridFillRenderer.prototype.attachSegs = function (type, segs) {\n    var els = [];\n    var i;\n    var seg;\n    var skeletonEl;\n\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      skeletonEl = this.renderFillRow(type, seg);\n      this.dayGrid.rowEls[seg.row].appendChild(skeletonEl);\n      els.push(skeletonEl);\n    }\n\n    return els;\n  }; // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n\n\n  DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {\n    var dayGrid = this.dayGrid;\n    var isRtl = this.context.isRtl;\n    var colCnt = dayGrid.colCnt;\n    var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;\n    var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;\n    var startCol = leftCol;\n    var endCol = rightCol + 1;\n    var className;\n    var skeletonEl;\n    var trEl;\n\n    if (type === 'businessHours') {\n      className = 'bgevent';\n    } else {\n      className = type.toLowerCase();\n    }\n\n    skeletonEl = htmlToElement('<div class=\"fc-' + className + '-skeleton\">' + '<table><tr></tr></table>' + '</div>');\n    trEl = skeletonEl.getElementsByTagName('tr')[0];\n\n    if (startCol > 0) {\n      appendToElement(trEl, // will create (startCol + 1) td's\n      new Array(startCol + 1).join(EMPTY_CELL_HTML));\n    }\n\n    seg.el.colSpan = endCol - startCol;\n    trEl.appendChild(seg.el);\n\n    if (endCol < colCnt) {\n      appendToElement(trEl, // will create (colCnt - endCol) td's\n      new Array(colCnt - endCol + 1).join(EMPTY_CELL_HTML));\n    }\n\n    var introHtml = dayGrid.renderProps.renderIntroHtml();\n\n    if (introHtml) {\n      if (isRtl) {\n        appendToElement(trEl, introHtml);\n      } else {\n        prependToElement(trEl, introHtml);\n      }\n    }\n\n    return skeletonEl;\n  };\n\n  return DayGridFillRenderer;\n}(FillRenderer);\n\nvar DayTile =\n/** @class */\nfunction (_super) {\n  __extends(DayTile, _super);\n\n  function DayTile(el) {\n    var _this = _super.call(this, el) || this;\n\n    var eventRenderer = _this.eventRenderer = new DayTileEventRenderer(_this);\n    var renderFrame = _this.renderFrame = memoizeRendering(_this._renderFrame);\n    _this.renderFgEvents = memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderFrame]);\n    _this.renderEventSelection = memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n    _this.renderEventDrag = memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);\n    _this.renderEventResize = memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);\n    return _this;\n  }\n\n  DayTile.prototype.firstContext = function (context) {\n    context.calendar.registerInteractiveComponent(this, {\n      el: this.el,\n      useEventCenter: false\n    });\n  };\n\n  DayTile.prototype.render = function (props, context) {\n    this.renderFrame(props.date);\n    this.renderFgEvents(context, props.fgSegs);\n    this.renderEventSelection(props.eventSelection);\n    this.renderEventDrag(props.eventDragInstances);\n    this.renderEventResize(props.eventResizeInstances);\n  };\n\n  DayTile.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.renderFrame.unrender(); // should unrender everything else\n\n    this.context.calendar.unregisterInteractiveComponent(this);\n  };\n\n  DayTile.prototype._renderFrame = function (date) {\n    var _a = this.context,\n        theme = _a.theme,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n    var title = dateEnv.format(date, createFormatter(options.dayPopoverFormat) // TODO: cache\n    );\n    this.el.innerHTML = '<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' + '<span class=\"fc-title\">' + htmlEscape(title) + '</span>' + '<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' + '</div>' + '<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' + '<div class=\"fc-event-container\"></div>' + '</div>';\n    this.segContainerEl = this.el.querySelector('.fc-event-container');\n  };\n\n  DayTile.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var date = this.props.date; // HACK\n\n    if (positionLeft < elWidth && positionTop < elHeight) {\n      return {\n        component: this,\n        dateSpan: {\n          allDay: true,\n          range: {\n            start: date,\n            end: addDays(date, 1)\n          }\n        },\n        dayEl: this.el,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1\n      };\n    }\n  };\n\n  return DayTile;\n}(DateComponent);\n\nvar DayTileEventRenderer =\n/** @class */\nfunction (_super) {\n  __extends(DayTileEventRenderer, _super);\n\n  function DayTileEventRenderer(dayTile) {\n    var _this = _super.call(this) || this;\n\n    _this.dayTile = dayTile;\n    return _this;\n  }\n\n  DayTileEventRenderer.prototype.attachSegs = function (segs) {\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      this.dayTile.segContainerEl.appendChild(seg.el);\n    }\n  };\n\n  DayTileEventRenderer.prototype.detachSegs = function (segs) {\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      removeElement(seg.el);\n    }\n  };\n\n  return DayTileEventRenderer;\n}(SimpleDayGridEventRenderer);\n\nvar DayBgRow =\n/** @class */\nfunction () {\n  function DayBgRow(context) {\n    this.context = context;\n  }\n\n  DayBgRow.prototype.renderHtml = function (props) {\n    var parts = [];\n\n    if (props.renderIntroHtml) {\n      parts.push(props.renderIntroHtml());\n    }\n\n    for (var _i = 0, _a = props.cells; _i < _a.length; _i++) {\n      var cell = _a[_i];\n      parts.push(renderCellHtml(cell.date, props.dateProfile, this.context, cell.htmlAttrs));\n    }\n\n    if (!props.cells.length) {\n      parts.push('<td class=\"fc-day ' + this.context.theme.getClass('widgetContent') + '\"></td>');\n    }\n\n    if (this.context.options.dir === 'rtl') {\n      parts.reverse();\n    }\n\n    return '<tr>' + parts.join('') + '</tr>';\n  };\n\n  return DayBgRow;\n}();\n\nfunction renderCellHtml(date, dateProfile, context, otherAttrs) {\n  var dateEnv = context.dateEnv,\n      theme = context.theme;\n  var isDateValid = rangeContainsMarker(dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.\n\n  var classes = getDayClasses(date, dateProfile, context);\n  classes.unshift('fc-day', theme.getClass('widgetContent'));\n  return '<td class=\"' + classes.join(' ') + '\"' + (isDateValid ? ' data-date=\"' + dateEnv.formatIso(date, {\n    omitTime: true\n  }) + '\"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '></td>';\n}\n\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\nvar WEEK_NUM_FORMAT = createFormatter({\n  week: 'numeric'\n});\n\nvar DayGrid =\n/** @class */\nfunction (_super) {\n  __extends(DayGrid, _super);\n\n  function DayGrid(el, renderProps) {\n    var _this = _super.call(this, el) || this;\n\n    _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid\n\n    _this.isCellSizesDirty = false;\n    _this.renderProps = renderProps;\n    var eventRenderer = _this.eventRenderer = new DayGridEventRenderer(_this);\n    var fillRenderer = _this.fillRenderer = new DayGridFillRenderer(_this);\n    _this.mirrorRenderer = new DayGridMirrorRenderer(_this);\n    var renderCells = _this.renderCells = memoizeRendering(_this._renderCells, _this._unrenderCells);\n    _this.renderBusinessHours = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderCells]);\n    _this.renderDateSelection = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'), [renderCells]);\n    _this.renderBgEvents = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderCells]);\n    _this.renderFgEvents = memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderCells]);\n    _this.renderEventSelection = memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n    _this.renderEventDrag = memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderCells]);\n    _this.renderEventResize = memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderCells]);\n    return _this;\n  }\n\n  DayGrid.prototype.render = function (props, context) {\n    var cells = props.cells;\n    this.rowCnt = cells.length;\n    this.colCnt = cells[0].length;\n    this.renderCells(cells, props.isRigid);\n    this.renderBusinessHours(context, props.businessHourSegs);\n    this.renderDateSelection(context, props.dateSelectionSegs);\n    this.renderBgEvents(context, props.bgEventSegs);\n    this.renderFgEvents(context, props.fgEventSegs);\n    this.renderEventSelection(props.eventSelection);\n    this.renderEventDrag(props.eventDrag);\n    this.renderEventResize(props.eventResize);\n\n    if (this.segPopoverTile) {\n      this.updateSegPopoverTile();\n    }\n  };\n\n  DayGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.renderCells.unrender(); // will unrender everything else\n  };\n\n  DayGrid.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = addDays(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  DayGrid.prototype.updateSegPopoverTile = function (date, segs) {\n    var ownProps = this.props;\n    this.segPopoverTile.receiveProps({\n      date: date || this.segPopoverTile.props.date,\n      fgSegs: segs || this.segPopoverTile.props.fgSegs,\n      eventSelection: ownProps.eventSelection,\n      eventDragInstances: ownProps.eventDrag ? ownProps.eventDrag.affectedInstances : null,\n      eventResizeInstances: ownProps.eventResize ? ownProps.eventResize.affectedInstances : null\n    }, this.context);\n  };\n  /* Date Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype._renderCells = function (cells, isRigid) {\n    var _a = this.context,\n        calendar = _a.calendar,\n        view = _a.view,\n        isRtl = _a.isRtl,\n        dateEnv = _a.dateEnv;\n\n    var _b = this,\n        rowCnt = _b.rowCnt,\n        colCnt = _b.colCnt;\n\n    var html = '';\n    var row;\n    var col;\n\n    for (row = 0; row < rowCnt; row++) {\n      html += this.renderDayRowHtml(row, isRigid);\n    }\n\n    this.el.innerHTML = html;\n    this.rowEls = findElements(this.el, '.fc-row');\n    this.cellEls = findElements(this.el, '.fc-day, .fc-disabled-day');\n\n    if (isRtl) {\n      this.cellEls.reverse();\n    }\n\n    this.rowPositions = new PositionCache(this.el, this.rowEls, false, true // vertical\n    );\n    this.colPositions = new PositionCache(this.el, this.cellEls.slice(0, colCnt), // only the first row\n    true, false // horizontal\n    ); // trigger dayRender with each cell's element\n\n    for (row = 0; row < rowCnt; row++) {\n      for (col = 0; col < colCnt; col++) {\n        calendar.publiclyTrigger('dayRender', [{\n          date: dateEnv.toDate(cells[row][col].date),\n          el: this.getCellEl(row, col),\n          view: view\n        }]);\n      }\n    }\n\n    this.isCellSizesDirty = true;\n  };\n\n  DayGrid.prototype._unrenderCells = function () {\n    this.removeSegPopover();\n  }; // Generates the HTML for a single row, which is a div that wraps a table.\n  // `row` is the row number.\n\n\n  DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {\n    var theme = this.context.theme;\n    var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];\n\n    if (isRigid) {\n      classes.push('fc-rigid');\n    }\n\n    var bgRow = new DayBgRow(this.context);\n    return '' + '<div class=\"' + classes.join(' ') + '\">' + '<div class=\"fc-bg\">' + '<table class=\"' + theme.getClass('tableGrid') + '\">' + bgRow.renderHtml({\n      cells: this.props.cells[row],\n      dateProfile: this.props.dateProfile,\n      renderIntroHtml: this.renderProps.renderBgIntroHtml\n    }) + '</table>' + '</div>' + '<div class=\"fc-content-skeleton\">' + '<table>' + (this.getIsNumbersVisible() ? '<thead>' + this.renderNumberTrHtml(row) + '</thead>' : '') + '</table>' + '</div>' + '</div>';\n  };\n\n  DayGrid.prototype.getIsNumbersVisible = function () {\n    return this.getIsDayNumbersVisible() || this.renderProps.cellWeekNumbersVisible || this.renderProps.colWeekNumbersVisible;\n  };\n\n  DayGrid.prototype.getIsDayNumbersVisible = function () {\n    return this.rowCnt > 1;\n  };\n  /* Grid Number Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype.renderNumberTrHtml = function (row) {\n    var isRtl = this.context.isRtl;\n    var intro = this.renderProps.renderNumberIntroHtml(row, this);\n    return '' + '<tr>' + (isRtl ? '' : intro) + this.renderNumberCellsHtml(row) + (isRtl ? intro : '') + '</tr>';\n  };\n\n  DayGrid.prototype.renderNumberCellsHtml = function (row) {\n    var htmls = [];\n    var col;\n    var date;\n\n    for (col = 0; col < this.colCnt; col++) {\n      date = this.props.cells[row][col].date;\n      htmls.push(this.renderNumberCellHtml(date));\n    }\n\n    if (this.context.isRtl) {\n      htmls.reverse();\n    }\n\n    return htmls.join('');\n  }; // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n  // The number row will only exist if either day numbers or week numbers are turned on.\n\n\n  DayGrid.prototype.renderNumberCellHtml = function (date) {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n    var html = '';\n    var isDateValid = rangeContainsMarker(this.props.dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.\n\n    var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\n    var classes;\n    var weekCalcFirstDow;\n\n    if (!isDayNumberVisible && !this.renderProps.cellWeekNumbersVisible) {\n      // no numbers in day cell (week number must be along the side)\n      return '<td></td>'; //  will create an empty space above events :(\n    }\n\n    classes = getDayClasses(date, this.props.dateProfile, this.context);\n    classes.unshift('fc-day-top');\n\n    if (this.renderProps.cellWeekNumbersVisible) {\n      weekCalcFirstDow = dateEnv.weekDow;\n    }\n\n    html += '<td class=\"' + classes.join(' ') + '\"' + (isDateValid ? ' data-date=\"' + dateEnv.formatIso(date, {\n      omitTime: true\n    }) + '\"' : '') + '>';\n\n    if (this.renderProps.cellWeekNumbersVisible && date.getUTCDay() === weekCalcFirstDow) {\n      html += buildGotoAnchorHtml(options, dateEnv, {\n        date: date,\n        type: 'week'\n      }, {\n        'class': 'fc-week-number'\n      }, dateEnv.format(date, WEEK_NUM_FORMAT) // inner HTML\n      );\n    }\n\n    if (isDayNumberVisible) {\n      html += buildGotoAnchorHtml(options, dateEnv, date, {\n        'class': 'fc-day-number'\n      }, dateEnv.format(date, DAY_NUM_FORMAT) // inner HTML\n      );\n    }\n\n    html += '</td>';\n    return html;\n  };\n  /* Sizing\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype.updateSize = function (isResize) {\n    var calendar = this.context.calendar;\n\n    var _a = this,\n        fillRenderer = _a.fillRenderer,\n        eventRenderer = _a.eventRenderer,\n        mirrorRenderer = _a.mirrorRenderer;\n\n    if (isResize || this.isCellSizesDirty || calendar.isEventsUpdated // hack\n    ) {\n        this.buildPositionCaches();\n        this.isCellSizesDirty = false;\n      }\n\n    fillRenderer.computeSizes(isResize);\n    eventRenderer.computeSizes(isResize);\n    mirrorRenderer.computeSizes(isResize);\n    fillRenderer.assignSizes(isResize);\n    eventRenderer.assignSizes(isResize);\n    mirrorRenderer.assignSizes(isResize);\n  };\n\n  DayGrid.prototype.buildPositionCaches = function () {\n    this.buildColPositions();\n    this.buildRowPositions();\n  };\n\n  DayGrid.prototype.buildColPositions = function () {\n    this.colPositions.build();\n  };\n\n  DayGrid.prototype.buildRowPositions = function () {\n    this.rowPositions.build();\n    this.rowPositions.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n  };\n  /* Hit System\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype.positionToHit = function (leftPosition, topPosition) {\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(leftPosition);\n    var row = rowPositions.topToIndex(topPosition);\n\n    if (row != null && col != null) {\n      return {\n        row: row,\n        col: col,\n        dateSpan: {\n          range: this.getCellRange(row, col),\n          allDay: true\n        },\n        dayEl: this.getCellEl(row, col),\n        relativeRect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        }\n      };\n    }\n  };\n  /* Cell System\n  ------------------------------------------------------------------------------------------------------------------*/\n  // FYI: the first column is the leftmost column, regardless of date\n\n\n  DayGrid.prototype.getCellEl = function (row, col) {\n    return this.cellEls[row * this.colCnt + col];\n  };\n  /* Event Drag Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype._renderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      this.fillRenderer.renderSegs('highlight', this.context, state.segs);\n    }\n  };\n\n  DayGrid.prototype._unrenderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.fillRenderer.unrender('highlight', this.context);\n    }\n  };\n  /* Event Resize Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype._renderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      this.fillRenderer.renderSegs('highlight', this.context, state.segs);\n      this.mirrorRenderer.renderSegs(this.context, state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n\n  DayGrid.prototype._unrenderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.fillRenderer.unrender('highlight', this.context);\n      this.mirrorRenderer.unrender(this.context, state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n  /* More+ Link Popover\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  DayGrid.prototype.removeSegPopover = function () {\n    if (this.segPopover) {\n      this.segPopover.hide(); // in handler, will call segPopover's removeElement\n    }\n  }; // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n  // `levelLimit` can be false (don't limit), a number, or true (should be computed).\n\n\n  DayGrid.prototype.limitRows = function (levelLimit) {\n    var rowStructs = this.eventRenderer.rowStructs || [];\n    var row; // row #\n\n    var rowLevelLimit;\n\n    for (row = 0; row < rowStructs.length; row++) {\n      this.unlimitRow(row);\n\n      if (!levelLimit) {\n        rowLevelLimit = false;\n      } else if (typeof levelLimit === 'number') {\n        rowLevelLimit = levelLimit;\n      } else {\n        rowLevelLimit = this.computeRowLevelLimit(row);\n      }\n\n      if (rowLevelLimit !== false) {\n        this.limitRow(row, rowLevelLimit);\n      }\n    }\n  }; // Computes the number of levels a row will accomodate without going outside its bounds.\n  // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n  // `row` is the row number.\n\n\n  DayGrid.prototype.computeRowLevelLimit = function (row) {\n    var rowEl = this.rowEls[row]; // the containing \"fake\" row div\n\n    var rowBottom = rowEl.getBoundingClientRect().bottom; // relative to viewport!\n\n    var trEls = findChildren(this.eventRenderer.rowStructs[row].tbodyEl);\n    var i;\n    var trEl; // Reveal one level <tr> at a time and stop when we find one out of bounds\n\n    for (i = 0; i < trEls.length; i++) {\n      trEl = trEls[i];\n      trEl.classList.remove('fc-limited'); // reset to original state (reveal)\n\n      if (trEl.getBoundingClientRect().bottom > rowBottom) {\n        return i;\n      }\n    }\n\n    return false; // should not limit at all\n  }; // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n  // `row` is the row number.\n  // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n\n\n  DayGrid.prototype.limitRow = function (row, levelLimit) {\n    var _this = this;\n\n    var colCnt = this.colCnt;\n    var isRtl = this.context.isRtl;\n    var rowStruct = this.eventRenderer.rowStructs[row];\n    var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n\n    var col = 0; // col #, left-to-right (not chronologically)\n\n    var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n\n    var cellMatrix; // a matrix (by level, then column) of all <td> elements in the row\n\n    var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n\n    var i;\n    var seg;\n    var segsBelow; // array of segment objects below `seg` in the current `col`\n\n    var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n\n    var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n\n    var td;\n    var rowSpan;\n    var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n\n    var j;\n    var moreTd;\n    var moreWrap;\n    var moreLink; // Iterates through empty level cells and places \"more\" links inside if need be\n\n    var emptyCellsUntil = function emptyCellsUntil(endCol) {\n      while (col < endCol) {\n        segsBelow = _this.getCellSegs(row, col, levelLimit);\n\n        if (segsBelow.length) {\n          td = cellMatrix[levelLimit - 1][col];\n          moreLink = _this.renderMoreLink(row, col, segsBelow);\n          moreWrap = createElement('div', null, moreLink);\n          td.appendChild(moreWrap);\n          moreNodes.push(moreWrap);\n        }\n\n        col++;\n      }\n    };\n\n    if (levelLimit && levelLimit < rowStruct.segLevels.length) {\n      // is it actually over the limit?\n      levelSegs = rowStruct.segLevels[levelLimit - 1];\n      cellMatrix = rowStruct.cellMatrix;\n      limitedNodes = findChildren(rowStruct.tbodyEl).slice(levelLimit); // get level <tr> elements past the limit\n\n      limitedNodes.forEach(function (node) {\n        node.classList.add('fc-limited'); // hide elements and get a simple DOM-nodes array\n      }); // iterate though segments in the last allowable level\n\n      for (i = 0; i < levelSegs.length; i++) {\n        seg = levelSegs[i];\n        var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;\n        var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;\n        emptyCellsUntil(leftCol); // process empty cells before the segment\n        // determine *all* segments below `seg` that occupy the same columns\n\n        colSegsBelow = [];\n        totalSegsBelow = 0;\n\n        while (col <= rightCol) {\n          segsBelow = this.getCellSegs(row, col, levelLimit);\n          colSegsBelow.push(segsBelow);\n          totalSegsBelow += segsBelow.length;\n          col++;\n        }\n\n        if (totalSegsBelow) {\n          // do we need to replace this segment with one or many \"more\" links?\n          td = cellMatrix[levelLimit - 1][leftCol]; // the segment's parent cell\n\n          rowSpan = td.rowSpan || 1;\n          segMoreNodes = []; // make a replacement <td> for each column the segment occupies. will be one for each colspan\n\n          for (j = 0; j < colSegsBelow.length; j++) {\n            moreTd = createElement('td', {\n              className: 'fc-more-cell',\n              rowSpan: rowSpan\n            });\n            segsBelow = colSegsBelow[j];\n            moreLink = this.renderMoreLink(row, leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\n            );\n            moreWrap = createElement('div', null, moreLink);\n            moreTd.appendChild(moreWrap);\n            segMoreNodes.push(moreTd);\n            moreNodes.push(moreTd);\n          }\n\n          td.classList.add('fc-limited');\n          insertAfterElement(td, segMoreNodes);\n          limitedNodes.push(td);\n        }\n      }\n\n      emptyCellsUntil(this.colCnt); // finish off the level\n\n      rowStruct.moreEls = moreNodes; // for easy undoing later\n\n      rowStruct.limitedEls = limitedNodes; // for easy undoing later\n    }\n  }; // Reveals all levels and removes all \"more\"-related elements for a grid's row.\n  // `row` is a row number.\n\n\n  DayGrid.prototype.unlimitRow = function (row) {\n    var rowStruct = this.eventRenderer.rowStructs[row];\n\n    if (rowStruct.moreEls) {\n      rowStruct.moreEls.forEach(removeElement);\n      rowStruct.moreEls = null;\n    }\n\n    if (rowStruct.limitedEls) {\n      rowStruct.limitedEls.forEach(function (limitedEl) {\n        limitedEl.classList.remove('fc-limited');\n      });\n      rowStruct.limitedEls = null;\n    }\n  }; // Renders an <a> element that represents hidden event element for a cell.\n  // Responsible for attaching click handler as well.\n\n\n  DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {\n    var _this = this;\n\n    var _a = this.context,\n        calendar = _a.calendar,\n        view = _a.view,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        isRtl = _a.isRtl;\n    var a = createElement('a', {\n      className: 'fc-more'\n    });\n    a.innerText = this.getMoreLinkText(hiddenSegs.length);\n    a.addEventListener('click', function (ev) {\n      var clickOption = options.eventLimitClick;\n\n      var _col = isRtl ? _this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?\n\n\n      var date = _this.props.cells[row][_col].date;\n      var moreEl = ev.currentTarget;\n\n      var dayEl = _this.getCellEl(row, col);\n\n      var allSegs = _this.getCellSegs(row, col); // rescope the segments to be within the cell's date\n\n\n      var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n\n      var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n\n      if (typeof clickOption === 'function') {\n        // the returned value can be an atomic option\n        clickOption = calendar.publiclyTrigger('eventLimitClick', [{\n          date: dateEnv.toDate(date),\n          allDay: true,\n          dayEl: dayEl,\n          moreEl: moreEl,\n          segs: reslicedAllSegs,\n          hiddenSegs: reslicedHiddenSegs,\n          jsEvent: ev,\n          view: view\n        }]);\n      }\n\n      if (clickOption === 'popover') {\n        _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n      } else if (typeof clickOption === 'string') {\n        // a view name\n        calendar.zoomTo(date, clickOption);\n      }\n    });\n    return a;\n  }; // Reveals the popover that displays all events within a cell\n\n\n  DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {\n    var _this = this;\n\n    var _a = this.context,\n        calendar = _a.calendar,\n        view = _a.view,\n        theme = _a.theme,\n        isRtl = _a.isRtl;\n\n    var _col = isRtl ? this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?\n\n\n    var moreWrap = moreLink.parentNode; // the <div> wrapper around the <a>\n\n    var topEl; // the element we want to match the top coordinate of\n\n    var options;\n\n    if (this.rowCnt === 1) {\n      topEl = view.el; // will cause the popover to cover any sort of header\n    } else {\n      topEl = this.rowEls[row]; // will align with top of row\n    }\n\n    options = {\n      className: 'fc-more-popover ' + theme.getClass('popover'),\n      parentEl: view.el,\n      top: computeRect(topEl).top,\n      autoHide: true,\n      content: function content(el) {\n        _this.segPopoverTile = new DayTile(el);\n\n        _this.updateSegPopoverTile(_this.props.cells[row][_col].date, segs);\n      },\n      hide: function hide() {\n        _this.segPopoverTile.destroy();\n\n        _this.segPopoverTile = null;\n\n        _this.segPopover.destroy();\n\n        _this.segPopover = null;\n      }\n    }; // Determine horizontal coordinate.\n    // We use the moreWrap instead of the <td> to avoid border confusion.\n\n    if (isRtl) {\n      options.right = computeRect(moreWrap).right + 1; // +1 to be over cell border\n    } else {\n      options.left = computeRect(moreWrap).left - 1; // -1 to be over cell border\n    }\n\n    this.segPopover = new Popover(options);\n    this.segPopover.show();\n    calendar.releaseAfterSizingTriggers(); // hack for eventPositioned\n  }; // Given the events within an array of segment objects, reslice them to be in a single day\n\n\n  DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {\n    var dayStart = dayDate;\n    var dayEnd = addDays(dayStart, 1);\n    var dayRange = {\n      start: dayStart,\n      end: dayEnd\n    };\n    var newSegs = [];\n\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      var eventRange = seg.eventRange;\n      var origRange = eventRange.range;\n      var slicedRange = intersectRanges(origRange, dayRange);\n\n      if (slicedRange) {\n        newSegs.push(_assign({}, seg, {\n          eventRange: {\n            def: eventRange.def,\n            ui: _assign({}, eventRange.ui, {\n              durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n          },\n          isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n          isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n        }));\n      }\n    }\n\n    return newSegs;\n  }; // Generates the text that should be inside a \"more\" link, given the number of events it represents\n\n\n  DayGrid.prototype.getMoreLinkText = function (num) {\n    var opt = this.context.options.eventLimitText;\n\n    if (typeof opt === 'function') {\n      return opt(num);\n    } else {\n      return '+' + num + ' ' + opt;\n    }\n  }; // Returns segments within a given cell.\n  // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n\n\n  DayGrid.prototype.getCellSegs = function (row, col, startLevel) {\n    var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\n    var level = startLevel || 0;\n    var segs = [];\n    var seg;\n\n    while (level < segMatrix.length) {\n      seg = segMatrix[level][col];\n\n      if (seg) {\n        segs.push(seg);\n      }\n\n      level++;\n    }\n\n    return segs;\n  };\n\n  return DayGrid;\n}(DateComponent);\n\nvar WEEK_NUM_FORMAT$1 = createFormatter({\n  week: 'numeric'\n});\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar AbstractDayGridView =\n/** @class */\nfunction (_super) {\n  __extends(AbstractDayGridView, _super);\n\n  function AbstractDayGridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processOptions = memoize(_this._processOptions);\n    _this.renderSkeleton = memoizeRendering(_this._renderSkeleton, _this._unrenderSkeleton);\n    /* Header Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that will go before the day-of week header cells\n\n    _this.renderHeadIntroHtml = function () {\n      var _a = _this.context,\n          theme = _a.theme,\n          options = _a.options;\n\n      if (_this.colWeekNumbersVisible) {\n        return '' + '<th class=\"fc-week-number ' + theme.getClass('widgetHeader') + '\" ' + _this.weekNumberStyleAttr() + '>' + '<span>' + // needed for matchCellWidths\n        htmlEscape(options.weekLabel) + '</span>' + '</th>';\n      }\n\n      return '';\n    };\n    /* Day Grid Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n\n\n    _this.renderDayGridNumberIntroHtml = function (row, dayGrid) {\n      var _a = _this.context,\n          options = _a.options,\n          dateEnv = _a.dateEnv;\n      var weekStart = dayGrid.props.cells[row][0].date;\n\n      if (_this.colWeekNumbersVisible) {\n        return '' + '<td class=\"fc-week-number\" ' + _this.weekNumberStyleAttr() + '>' + buildGotoAnchorHtml( // aside from link, important for matchCellWidths\n        options, dateEnv, {\n          date: weekStart,\n          type: 'week',\n          forceOff: dayGrid.colCnt === 1\n        }, dateEnv.format(weekStart, WEEK_NUM_FORMAT$1) // inner HTML\n        ) + '</td>';\n      }\n\n      return '';\n    }; // Generates the HTML that goes before the day bg cells for each day-row\n\n\n    _this.renderDayGridBgIntroHtml = function () {\n      var theme = _this.context.theme;\n\n      if (_this.colWeekNumbersVisible) {\n        return '<td class=\"fc-week-number ' + theme.getClass('widgetContent') + '\" ' + _this.weekNumberStyleAttr() + '></td>';\n      }\n\n      return '';\n    }; // Generates the HTML that goes before every other type of row generated by DayGrid.\n    // Affects mirror-skeleton and highlight-skeleton rows.\n\n\n    _this.renderDayGridIntroHtml = function () {\n      if (_this.colWeekNumbersVisible) {\n        return '<td class=\"fc-week-number\" ' + _this.weekNumberStyleAttr() + '></td>';\n      }\n\n      return '';\n    };\n\n    return _this;\n  }\n\n  AbstractDayGridView.prototype._processOptions = function (options) {\n    if (options.weekNumbers) {\n      if (options.weekNumbersWithinDays) {\n        this.cellWeekNumbersVisible = true;\n        this.colWeekNumbersVisible = false;\n      } else {\n        this.cellWeekNumbersVisible = false;\n        this.colWeekNumbersVisible = true;\n      }\n    } else {\n      this.colWeekNumbersVisible = false;\n      this.cellWeekNumbersVisible = false;\n    }\n  };\n\n  AbstractDayGridView.prototype.render = function (props, context) {\n    _super.prototype.render.call(this, props, context);\n\n    this.processOptions(context.options);\n    this.renderSkeleton(context);\n  };\n\n  AbstractDayGridView.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.renderSkeleton.unrender();\n  };\n\n  AbstractDayGridView.prototype._renderSkeleton = function (context) {\n    this.el.classList.add('fc-dayGrid-view');\n    this.el.innerHTML = this.renderSkeletonHtml();\n    this.scroller = new ScrollComponent('hidden', // overflow x\n    'auto' // overflow y\n    );\n    var dayGridContainerEl = this.scroller.el;\n    this.el.querySelector('.fc-body > tr > td').appendChild(dayGridContainerEl);\n    dayGridContainerEl.classList.add('fc-day-grid-container');\n    var dayGridEl = createElement('div', {\n      className: 'fc-day-grid'\n    });\n    dayGridContainerEl.appendChild(dayGridEl);\n    this.dayGrid = new DayGrid(dayGridEl, {\n      renderNumberIntroHtml: this.renderDayGridNumberIntroHtml,\n      renderBgIntroHtml: this.renderDayGridBgIntroHtml,\n      renderIntroHtml: this.renderDayGridIntroHtml,\n      colWeekNumbersVisible: this.colWeekNumbersVisible,\n      cellWeekNumbersVisible: this.cellWeekNumbersVisible\n    });\n  };\n\n  AbstractDayGridView.prototype._unrenderSkeleton = function () {\n    this.el.classList.remove('fc-dayGrid-view');\n    this.dayGrid.destroy();\n    this.scroller.destroy();\n  }; // Builds the HTML skeleton for the view.\n  // The day-grid component will render inside of a container defined by this HTML.\n\n\n  AbstractDayGridView.prototype.renderSkeletonHtml = function () {\n    var _a = this.context,\n        theme = _a.theme,\n        options = _a.options;\n    return '' + '<table class=\"' + theme.getClass('tableGrid') + '\">' + (options.columnHeader ? '<thead class=\"fc-head\">' + '<tr>' + '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class=\"fc-body\">' + '<tr>' + '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' + '</tr>' + '</tbody>' + '</table>';\n  }; // Generates an HTML attribute string for setting the width of the week number column, if it is known\n\n\n  AbstractDayGridView.prototype.weekNumberStyleAttr = function () {\n    if (this.weekNumberWidth != null) {\n      return 'style=\"width:' + this.weekNumberWidth + 'px\"';\n    }\n\n    return '';\n  }; // Determines whether each row should have a constant height\n\n\n  AbstractDayGridView.prototype.hasRigidRows = function () {\n    var eventLimit = this.context.options.eventLimit;\n    return eventLimit && typeof eventLimit !== 'number';\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  AbstractDayGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {\n    _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first\n\n\n    this.dayGrid.updateSize(isResize);\n  }; // Refreshes the horizontal dimensions of the view\n\n\n  AbstractDayGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {\n    var dayGrid = this.dayGrid;\n    var eventLimit = this.context.options.eventLimit;\n    var headRowEl = this.header ? this.header.el : null; // HACK\n\n    var scrollerHeight;\n    var scrollbarWidths; // hack to give the view some height prior to dayGrid's columns being rendered\n    // TODO: separate setting height from scroller VS dayGrid.\n\n    if (!dayGrid.rowEls) {\n      if (!isAuto) {\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      }\n\n      return;\n    }\n\n    if (this.colWeekNumbersVisible) {\n      // Make sure all week number cells running down the side have the same width.\n      this.weekNumberWidth = matchCellWidths(findElements(this.el, '.fc-week-number'));\n    } // reset all heights to be natural\n\n\n    this.scroller.clear();\n\n    if (headRowEl) {\n      uncompensateScroll(headRowEl);\n    }\n\n    dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n    // is the event limit a constant level number?\n\n    if (eventLimit && typeof eventLimit === 'number') {\n      dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n    } // distribute the height to the rows\n    // (viewHeight is a \"recommended\" value if isAuto)\n\n\n    scrollerHeight = this.computeScrollerHeight(viewHeight);\n    this.setGridHeight(scrollerHeight, isAuto); // is the event limit dynamically calculated?\n\n    if (eventLimit && typeof eventLimit !== 'number') {\n      dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n    }\n\n    if (!isAuto) {\n      // should we force dimensions of the scroll container?\n      this.scroller.setHeight(scrollerHeight);\n      scrollbarWidths = this.scroller.getScrollbarWidths();\n\n      if (scrollbarWidths.left || scrollbarWidths.right) {\n        // using scrollbars?\n        if (headRowEl) {\n          compensateScroll(headRowEl, scrollbarWidths);\n        } // doing the scrollbar compensation might have created text overflow which created more height. redo\n\n\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      } // guarantees the same scrollbar widths\n\n\n      this.scroller.lockOverflow(scrollbarWidths);\n    }\n  }; // given a desired total height of the view, returns what the height of the scroller should be\n\n\n  AbstractDayGridView.prototype.computeScrollerHeight = function (viewHeight) {\n    return viewHeight - subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n  }; // Sets the height of just the DayGrid component in this view\n\n\n  AbstractDayGridView.prototype.setGridHeight = function (height, isAuto) {\n    if (this.context.options.monthMode) {\n      // if auto, make the height of each row the height that it would be if there were 6 weeks\n      if (isAuto) {\n        height *= this.dayGrid.rowCnt / 6;\n      }\n\n      distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n    } else {\n      if (isAuto) {\n        undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n      } else {\n        distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n      }\n    }\n  };\n  /* Scroll\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  AbstractDayGridView.prototype.computeDateScroll = function (duration) {\n    return {\n      top: 0\n    };\n  };\n\n  AbstractDayGridView.prototype.queryDateScroll = function () {\n    return {\n      top: this.scroller.getScrollTop()\n    };\n  };\n\n  AbstractDayGridView.prototype.applyDateScroll = function (scroll) {\n    if (scroll.top !== undefined) {\n      this.scroller.setScrollTop(scroll.top);\n    }\n  };\n\n  return AbstractDayGridView;\n}(View);\n\nAbstractDayGridView.prototype.dateProfileGeneratorClass = DayGridDateProfileGenerator;\n\nvar SimpleDayGrid =\n/** @class */\nfunction (_super) {\n  __extends(SimpleDayGrid, _super);\n\n  function SimpleDayGrid(dayGrid) {\n    var _this = _super.call(this, dayGrid.el) || this;\n\n    _this.slicer = new DayGridSlicer();\n    _this.dayGrid = dayGrid;\n    return _this;\n  }\n\n  SimpleDayGrid.prototype.firstContext = function (context) {\n    context.calendar.registerInteractiveComponent(this, {\n      el: this.dayGrid.el\n    });\n  };\n\n  SimpleDayGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.context.calendar.unregisterInteractiveComponent(this);\n  };\n\n  SimpleDayGrid.prototype.render = function (props, context) {\n    var dayGrid = this.dayGrid;\n    var dateProfile = props.dateProfile,\n        dayTable = props.dayTable;\n    dayGrid.receiveProps(_assign({}, this.slicer.sliceProps(props, dateProfile, props.nextDayThreshold, context.calendar, dayGrid, dayTable), {\n      dateProfile: dateProfile,\n      cells: dayTable.cells,\n      isRigid: props.isRigid\n    }), context);\n  };\n\n  SimpleDayGrid.prototype.buildPositionCaches = function () {\n    this.dayGrid.buildPositionCaches();\n  };\n\n  SimpleDayGrid.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.dayGrid.positionToHit(positionLeft, positionTop);\n\n    if (rawHit) {\n      return {\n        component: this.dayGrid,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n  };\n\n  return SimpleDayGrid;\n}(DateComponent);\n\nvar DayGridSlicer =\n/** @class */\nfunction (_super) {\n  __extends(DayGridSlicer, _super);\n\n  function DayGridSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayGridSlicer.prototype.sliceRange = function (dateRange, dayTable) {\n    return dayTable.sliceRange(dateRange);\n  };\n\n  return DayGridSlicer;\n}(Slicer);\n\nvar DayGridView =\n/** @class */\nfunction (_super) {\n  __extends(DayGridView, _super);\n\n  function DayGridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTable = memoize(buildDayTable);\n    return _this;\n  }\n\n  DayGridView.prototype.render = function (props, context) {\n    _super.prototype.render.call(this, props, context); // will call _renderSkeleton/_unrenderSkeleton\n\n\n    var dateProfile = this.props.dateProfile;\n    var dayTable = this.dayTable = this.buildDayTable(dateProfile, props.dateProfileGenerator);\n\n    if (this.header) {\n      this.header.receiveProps({\n        dateProfile: dateProfile,\n        dates: dayTable.headerDates,\n        datesRepDistinctDays: dayTable.rowCnt === 1,\n        renderIntroHtml: this.renderHeadIntroHtml\n      }, context);\n    }\n\n    this.simpleDayGrid.receiveProps({\n      dateProfile: dateProfile,\n      dayTable: dayTable,\n      businessHours: props.businessHours,\n      dateSelection: props.dateSelection,\n      eventStore: props.eventStore,\n      eventUiBases: props.eventUiBases,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isRigid: this.hasRigidRows(),\n      nextDayThreshold: this.context.nextDayThreshold\n    }, context);\n  };\n\n  DayGridView.prototype._renderSkeleton = function (context) {\n    _super.prototype._renderSkeleton.call(this, context);\n\n    if (context.options.columnHeader) {\n      this.header = new DayHeader(this.el.querySelector('.fc-head-container'));\n    }\n\n    this.simpleDayGrid = new SimpleDayGrid(this.dayGrid);\n  };\n\n  DayGridView.prototype._unrenderSkeleton = function () {\n    _super.prototype._unrenderSkeleton.call(this);\n\n    if (this.header) {\n      this.header.destroy();\n    }\n\n    this.simpleDayGrid.destroy();\n  };\n\n  return DayGridView;\n}(AbstractDayGridView);\n\nfunction buildDayTable(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeries(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTable(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar main = createPlugin({\n  defaultView: 'dayGridMonth',\n  views: {\n    dayGrid: DayGridView,\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\nexport default main;\nexport { AbstractDayGridView, DayBgRow, DayGrid, DayGridSlicer, DayGridView, SimpleDayGrid, buildDayTable as buildBasicDayTable };","map":null,"metadata":{},"sourceType":"module"}