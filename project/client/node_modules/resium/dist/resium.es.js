import React, { createContext, useContext, useRef, useState, useCallback, useLayoutEffect, useEffect, useImperativeHandle, forwardRef, useMemo } from 'react';
import { Polyline as Polyline$1, DistanceDisplayCondition, ScreenSpaceEventType, ScreenSpaceEventHandler as ScreenSpaceEventHandler$1, Entity as Entity$1, Event, BillboardCollection as BillboardCollection$1, BillboardGraphics as BillboardGraphics$1, BoxGraphics as BoxGraphics$1, Cesium3DTileset as Cesium3DTileset$1, CesiumWidget as CesiumWidget$1, CorridorGraphics as CorridorGraphics$1, CustomDataSource as CustomDataSource$1, CylinderGraphics as CylinderGraphics$1, CzmlDataSource as CzmlDataSource$1, EllipseGraphics as EllipseGraphics$1, EllipsoidGraphics as EllipsoidGraphics$1, ConstantProperty, Fog as Fog$1, GeoJsonDataSource as GeoJsonDataSource$1, GroundPrimitive as GroundPrimitive$1, ImageryLayer as ImageryLayer$1, KmlDataSource as KmlDataSource$1, LabelCollection as LabelCollection$1, LabelGraphics as LabelGraphics$1, Model as Model$1, ModelGraphics as ModelGraphics$1, Moon as Moon$1, ParticleSystem as ParticleSystem$1, PathGraphics as PathGraphics$1, PlaneGraphics as PlaneGraphics$1, PointGraphics as PointGraphics$1, PointPrimitiveCollection as PointPrimitiveCollection$1, PolygonGraphics as PolygonGraphics$1, PolylineCollection as PolylineCollection$1, PolylineGraphics as PolylineGraphics$1, PolylineVolumeGraphics as PolylineVolumeGraphics$1, PostProcessStage as PostProcessStage$1, PostProcessStageLibrary, PostProcessStageComposite as PostProcessStageComposite$1, Primitive as Primitive$1, RectangleGraphics as RectangleGraphics$1, SceneMode, Sun as Sun$1, TimeDynamicPointCloud as TimeDynamicPointCloud$1, Viewer as Viewer$1, WallGraphics as WallGraphics$1 } from 'cesium';
import { createPortal } from 'react-dom';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var CesiumContext = createContext({});
var Provider = CesiumContext.Provider, Consumer = CesiumContext.Consumer;
var useCesium = function () { return useContext(CesiumContext); };

var polylineEquals = function (a, b) {
    return !!a &&
        !!b &&
        a instanceof Polyline$1 &&
        b instanceof Polyline$1 &&
        a.show === b.show &&
        a.width === b.width &&
        a.loop === b.loop &&
        a.material === b.material &&
        a.positions === b.positions &&
        a.id === b.id &&
        DistanceDisplayCondition.equals(a.distanceDisplayCondition,
        b.distanceDisplayCondition);
};
var pickedObjectEquals = function (picked, element) {
    return !!picked &&
        (picked === element ||
            (!!picked.id && picked.id === element) ||
            (!!picked.primitive &&
                (picked.primitive === element ||
                    (!!picked.primitive.equals && picked.primitive.equals(element)) ||
                    polylineEquals(picked.primitive, element))));
};
function pick(obj, keys) {
    if (!keys)
        return {};
    return entries(obj).reduce(function (a, _a) {
        var k = _a[0], v = _a[1];
        if (!includes(keys, k))
            return a;
        a[k] = v;
        return a;
    }, {});
}
function entries(obj) {
    return Object.keys(obj).map(function (k) { return [k, obj[k]]; });
}
function includes(array, value) {
    return !!array && array.indexOf(value) !== -1;
}
function shallowEquals(a1, a2) {
    return (!!a1 &&
        !!a2 &&
        __spreadArrays(Object.keys(a1), Object.keys(a2)).every(function (k) { return a1[k] === a2[k]; }));
}

var eventManagerContextKey = "__RESIUM_EVENT_MANAGER";
var eventNames = [
    "onClick",
    "onDoubleClick",
    "onMouseDown",
    "onMouseUp",
    "onMiddleClick",
    "onMiddleDown",
    "onMiddleUp",
    "onMouseMove",
    "onPinchEnd",
    "onPinchMove",
    "onPinchStart",
    "onRightClick",
    "onRightDown",
    "onRightUp",
    "onWheel",
    "onMouseEnter",
    "onMouseLeave",
];
var EventManager = /** @class */ (function () {
    function EventManager(scene) {
        var _this = this;
        var _a;
        this.events = {
            onClick: new Map(),
            onDoubleClick: new Map(),
            onMouseDown: new Map(),
            onMouseUp: new Map(),
            onMiddleClick: new Map(),
            onMiddleDown: new Map(),
            onMiddleUp: new Map(),
            onMouseMove: new Map(),
            onPinchEnd: new Map(),
            onPinchMove: new Map(),
            onPinchStart: new Map(),
            onRightClick: new Map(),
            onRightDown: new Map(),
            onRightUp: new Map(),
            onWheel: new Map(),
            onMouseEnter: new Map(),
            onMouseLeave: new Map(),
        };
        this.hovered = undefined;
        this.onMouseMove = function (e) {
            var picked = _this.pick(e.endPosition);
            if (_this.hovered !== picked) {
                if (_this.hovered) {
                    var onMouseLeave = _this.events.onMouseLeave.get(_this.hovered);
                    if (onMouseLeave) {
                        onMouseLeave(e, _this.hovered);
                    }
                    var onRootMouseLeave = _this.events.onMouseLeave.get(null);
                    if (onRootMouseLeave) {
                        onRootMouseLeave(e, _this.hovered);
                    }
                }
                if (picked) {
                    var onMouseEnter = _this.events.onMouseEnter.get(picked);
                    if (onMouseEnter) {
                        onMouseEnter(e, picked);
                    }
                    var onRootMouseEnter = _this.events.onMouseEnter.get(null);
                    if (onRootMouseEnter) {
                        onRootMouseEnter(e, picked);
                    }
                }
            }
            if (picked) {
                var onMouseMove = _this.events.onMouseMove.get(picked);
                if (onMouseMove) {
                    onMouseMove(e, picked);
                }
            }
            var onRootMouseMove = _this.events.onMouseMove.get(null);
            if (onRootMouseMove) {
                onRootMouseMove(e, picked);
            }
            _this.hovered = picked;
        };
        this.eventCallback = function (et) {
            var em = _this.events[et];
            return function (e) {
                var _a;
                var picked = _this.pick((_a = e) === null || _a === void 0 ? void 0 : _a.position);
                if (picked) {
                    em.forEach(function (cb, element) {
                        if (pickedObjectEquals(picked, element)) {
                            cb(e, picked);
                        }
                    });
                }
                var rootEvent = em.get(null);
                if (rootEvent) {
                    rootEvent(e, picked);
                }
            };
        };
        this.scene = scene;
        this.sshe = new ScreenSpaceEventHandler$1((_a = scene) === null || _a === void 0 ? void 0 : _a.canvas);
    }
    EventManager.prototype.destroy = function () {
        this.hovered = undefined;
        if (!this.sshe.isDestroyed()) {
            this.sshe.destroy();
        }
    };
    EventManager.prototype.isDestroyed = function () {
        return this.sshe.isDestroyed();
    };
    EventManager.prototype.on = function (element, type, cb) {
        if (element && type === "onWheel")
            return;
        this.events[type].set(element, cb);
    };
    EventManager.prototype.off = function (element, type) {
        this.events[type].delete(element);
        if (this.hovered === element) {
            this.hovered = undefined;
        }
    };
    EventManager.prototype.setEvents = function (element, props) {
        var _this = this;
        entries(props).forEach(function (_a) {
            var k = _a[0], v = _a[1];
            var et = k;
            if (includes(eventNames, et)) {
                if (v) {
                    _this.on(element, et, v);
                }
                else {
                    _this.off(element, et);
                }
            }
        });
        this.commit();
    };
    EventManager.prototype.clearEvents = function (element) {
        var _this = this;
        this.hovered = undefined;
        eventNames.forEach(function (et) {
            _this.off(element, et);
        });
        this.commit();
    };
    EventManager.prototype.commit = function () {
        var _this = this;
        var sshe = this.sshe;
        var destroyed = this.sshe.isDestroyed();
        if (!destroyed) {
            if (this.events.onMouseEnter.size === 0 &&
                this.events.onMouseLeave.size === 0 &&
                this.events.onMouseMove.size === 0) {
                this.sshe.removeInputAction(ScreenSpaceEventType.MOUSE_MOVE);
            }
            else if (!this.sshe.getInputAction(ScreenSpaceEventType.MOUSE_MOVE)) {
                this.sshe.setInputAction(this.onMouseMove, ScreenSpaceEventType.MOUSE_MOVE);
            }
        }
        entries(this.events).forEach(function (_a) {
            var et = _a[0], m = _a[1];
            if (et === "onMouseEnter" || et === "onMouseLeave" || et === "onMouseMove") {
                return;
            }
            var cesiumEventType = EventManager.eventTypeMap[et];
            if (!destroyed) {
                if (m.size === 0) {
                    sshe.removeInputAction(cesiumEventType);
                }
                else if (!sshe.getInputAction(cesiumEventType)) {
                    sshe.setInputAction(_this.eventCallback(et), cesiumEventType);
                }
            }
        });
    };
    EventManager.prototype.getScreenSpaceEventHandler = function () {
        return this.sshe;
    };
    EventManager.prototype.pick = function (pos) {
        if (!pos) {
            return undefined;
        }
        var picked = this.scene.pick(pos);
        if (picked) {
            if (picked.id instanceof Entity$1) {
                return picked.id;
            }
            return picked;
        }
        return undefined;
    };
    EventManager.eventTypeMap = {
        onClick: ScreenSpaceEventType.LEFT_CLICK,
        onDoubleClick: ScreenSpaceEventType.LEFT_DOUBLE_CLICK,
        onMouseDown: ScreenSpaceEventType.LEFT_DOWN,
        onMouseUp: ScreenSpaceEventType.LEFT_UP,
        onMiddleClick: ScreenSpaceEventType.MIDDLE_CLICK,
        onMiddleDown: ScreenSpaceEventType.MIDDLE_DOWN,
        onMiddleUp: ScreenSpaceEventType.MIDDLE_UP,
        onMouseMove: ScreenSpaceEventType.MOUSE_MOVE,
        onPinchEnd: ScreenSpaceEventType.PINCH_END,
        onPinchMove: ScreenSpaceEventType.PINCH_MOVE,
        onPinchStart: ScreenSpaceEventType.PINCH_START,
        onRightClick: ScreenSpaceEventType.RIGHT_CLICK,
        onRightDown: ScreenSpaceEventType.RIGHT_DOWN,
        onRightUp: ScreenSpaceEventType.RIGHT_UP,
        onWheel: ScreenSpaceEventType.WHEEL,
        onMouseEnter: ScreenSpaceEventType.MOUSE_MOVE,
        onMouseLeave: ScreenSpaceEventType.MOUSE_MOVE,
    };
    return EventManager;
}());

var useCesiumComponent = function (_a, props, ref) {
    var name = _a.name, create = _a.create, destroy = _a.destroy, provide = _a.provide, update = _a.update, cesiumProps = _a.cesiumProps, cesiumReadonlyProps = _a.cesiumReadonlyProps, cesiumEventProps = _a.cesiumEventProps, setCesiumPropsAfterCreate = _a.setCesiumPropsAfterCreate, useCommonEvent = _a.useCommonEvent, useRootEvent = _a.useRootEvent;
    var element = useRef();
    var ctx = useCesium();
    var provided = useRef(provide ? {} : undefined);
    var attachedEvents = useRef({});
    var initialProps = useRef(props);
    var prevProps = useRef({});
    var _b = useState(false), mounted = _b[0], setMounted = _b[1];
    var mountedRef = useRef(false);
    var wrapperRef = useRef(null);
    var stateRef = useRef();
    var eventManager = ctx[eventManagerContextKey];
    var updateProperties = useCallback(function (props) {
        var _a;
        if (!element.current)
            return;
        var target = element.current;
        var eventKeys = Object.keys(cesiumEventProps || []);
        var propDiff = __spreadArrays(Object.keys(props), Object.keys(prevProps.current)).filter(function (k) { return prevProps.current[k] !== props[k]; })
            .map(function (k) { return [k, prevProps.current[k], props[k]]; });
        var updatedReadonlyProps = [];
        for (var _i = 0, propDiff_1 = propDiff; _i < propDiff_1.length; _i++) {
            var _b = propDiff_1[_i], k = _b[0], prevValue = _b[1], newValue = _b[2];
            if (includes(cesiumProps, k)) {
                target[k] = newValue;
            }
            else if (includes(cesiumReadonlyProps, k)) {
                updatedReadonlyProps.push(k);
            }
            else if (includes(eventKeys, k)) {
                var cesiumKey = (_a = cesiumEventProps) === null || _a === void 0 ? void 0 : _a[k];
                var eventHandler = target[cesiumKey];
                if (eventHandler instanceof Event) {
                    if (typeof prevValue === "undefined") {
                        eventHandler.addEventListener(newValue);
                        attachedEvents.current[cesiumKey] = newValue;
                    }
                    else if (typeof newValue === "undefined") {
                        eventHandler.removeEventListener(prevValue);
                        delete attachedEvents.current[cesiumKey];
                    }
                    else {
                        eventHandler.removeEventListener(prevValue);
                        eventHandler.addEventListener(newValue);
                    }
                }
            }
        }
        var em = useRootEvent
            ? provided.current &&
                provided.current[eventManagerContextKey]
            : eventManager;
        if (useCommonEvent && em && element.current) {
            em.setEvents(useRootEvent ? null : element.current, props);
        }
        if (update && mountedRef.current) {
            update(element.current, props, prevProps.current, ctx);
        }
        prevProps.current = props;
        initialProps.current = props;
        if (mountedRef.current && updatedReadonlyProps.length > 0) {
            if (process.env.NODE_ENV !== "production") {
                console.warn("Warning: <" + name + "> is recreated because following read-only props have been updated: " + updatedReadonlyProps.join(", "));
            }
            unmount();
            mount();
        }
    }, []);
    var mount = useCallback(function () {
        var _a;
        var result = (_a = create) === null || _a === void 0 ? void 0 : _a(ctx, initialProps.current, wrapperRef.current);
        if (Array.isArray(result)) {
            element.current = result[0];
            stateRef.current = result[1];
        }
        else {
            element.current = result;
        }
        if (setCesiumPropsAfterCreate) {
            updateProperties(initialProps.current);
        }
        else {
            if (element.current && cesiumEventProps) {
                var target = element.current;
                for (var _i = 0, _b = Object.keys(initialProps.current); _i < _b.length; _i++) {
                    var key = _b[_i];
                    var eventKey = cesiumEventProps[key];
                    if (eventKey) {
                        var e = initialProps.current[key];
                        var eventHandler = target[eventKey];
                        if (e && eventHandler instanceof Event) {
                            eventHandler.addEventListener(e);
                        }
                    }
                }
            }
            prevProps.current = initialProps.current;
        }
        if (provide && element.current) {
            provided.current = __assign(__assign({}, ctx), provide(element.current, ctx, stateRef.current));
        }
        var em = useRootEvent
            ? provided.current &&
                provided.current[eventManagerContextKey]
            : eventManager;
        if (useCommonEvent && em && element.current) {
            em.setEvents(useRootEvent ? null : element.current, initialProps.current);
        }
    }, []);
    var unmount = useCallback(function () {
        var _a, _b, _c;
        if (element.current && destroy) {
            destroy(element.current, ctx, wrapperRef.current, stateRef.current);
        }
        var em = useRootEvent
            ? provided.current &&
                provided.current[eventManagerContextKey]
            : eventManager;
        if (useCommonEvent && em && element.current) {
            em.clearEvents(useRootEvent ? null : element.current);
        }
        if (element.current && !isDestroyed(element.current)) {
            var attachedEventKeys = Object.keys(attachedEvents.current);
            for (var _i = 0, attachedEventKeys_1 = attachedEventKeys; _i < attachedEventKeys_1.length; _i++) {
                var k = attachedEventKeys_1[_i];
                var eventHandler = element.current[k];
                (_c = (_a = eventHandler) === null || _a === void 0 ? void 0 : (_b = _a).removeEventListener) === null || _c === void 0 ? void 0 : _c.call(_b, attachedEvents.current[k]);
            }
        }
        attachedEvents.current = {};
        provided.current = undefined;
        stateRef.current = undefined;
        element.current = undefined;
        setMounted(false);
        mountedRef.current = false;
    }, []);
    useLayoutEffect(function () {
        mount();
        return function () { return unmount(); };
    }, []);
    useEffect(function () {
        if (mounted) {
            if (!shallowEquals(props, prevProps.current)) {
                updateProperties(props);
            }
        }
        else {
            prevProps.current = props;
            initialProps.current = props;
            setMounted(true);
            mountedRef.current = true;
        }
    }, [mounted, props, updateProperties]);
    useImperativeHandle(ref, function () { return ({
        cesiumElement: element.current,
    }); });
    return [provided.current, mounted, wrapperRef];
};
function isDestroyable(d) {
    return d && typeof d.isDestroyed === "function" && typeof d.destroy === "function";
}
function isDestroyed(d) {
    return isDestroyable(d) && d.isDestroyed();
}

var createCesiumComponent = function (_a) {
    var renderContainer = _a.renderContainer, noChildren = _a.noChildren, containerProps = _a.containerProps, defaultProps = _a.defaultProps, options = __rest(_a, ["renderContainer", "noChildren", "containerProps", "defaultProps"]);
    var component = function (props, ref) {
        var mergedProps = __assign(__assign({}, defaultProps), props);
        var _a = useCesiumComponent(options, mergedProps, ref), provided = _a[0], mounted = _a[1], wrapperRef = _a[2];
        if (noChildren)
            return null;
        var children = mounted ? mergedProps.children : null;
        var wrappedChildren = renderContainer ? (React.createElement("div", __assign({ ref: wrapperRef }, (typeof containerProps === "function"
            ? containerProps(mergedProps)
            : pick(mergedProps, containerProps))), children)) : (children);
        if (provided) {
            return React.createElement(CesiumContext.Provider, { value: provided }, wrappedChildren);
        }
        return wrappedChildren;
    };
    component.displayName = options.name;
    return forwardRef(component);
};

var createCameraOperation = function (name, cameraOperationStart) {
    var component = function (props) {
        var ctx = useCesium();
        var prevProps = useRef();
        var first = useRef(false);
        useEffect(function () {
            return function () {
                if (ctx.camera && props.cancelFlightOnUnmount) {
                    ctx.camera.cancelFlight();
                }
            };
        }, [ctx.camera, props.cancelFlightOnUnmount]);
        useEffect(function () {
            if (ctx.camera && ctx.scene && !ctx.scene.isDestroyed() && (!props.once || !first.current)) {
                ctx.camera.cancelFlight();
                cameraOperationStart(ctx.camera, props, prevProps.current);
                first.current = true;
            }
            prevProps.current = props;
        });
        return null;
    };
    component.displayName = name;
    return component;
};

var withCesium = function (Component) {
    return forwardRef(function (props, ref) { return (React.createElement(Consumer, null, function (value) { return React.createElement(Component, __assign({}, props, { ref: ref, cesium: value })); })); });
};

var cesiumProps = [
    "alignAxis",
    "color",
    "disableDepthTestDistance",
    "distanceDisplayCondition",
    "height",
    "heightReference",
    "horizontalOrigin",
    "id",
    "image",
    "pixelOffset",
    "pixelOffsetScaleByDistance",
    "position",
    "rotation",
    "scale",
    "scaleByDistance",
    "show",
    "sizeInMeters",
    "translucencyByDistance",
    "verticalOrigin",
    "width",
];
var Billboard = createCesiumComponent({
    name: "Billboard",
    create: function (context, props) {
        var _a;
        return (_a = context.billboardCollection) === null || _a === void 0 ? void 0 : _a.add(props);
    },
    destroy: function (element, context) {
        if (context.billboardCollection && !context.billboardCollection.isDestroyed()) {
            context.billboardCollection.remove(element);
        }
    },
    cesiumProps: cesiumProps,
    useCommonEvent: true,
});

var cesiumProps$1 = [
    "blendOption",
    "debugShowBoundingVolume",
    "length",
    "modelMatrix",
];
var BillboardCollection = createCesiumComponent({
    name: "BillboardCollection",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new BillboardCollection$1({
            modelMatrix: props.modelMatrix,
            debugShowBoundingVolume: props.debugShowBoundingVolume,
            scene: context.scene,
            blendOption: props.blendOption,
        });
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element) {
        return {
            billboardCollection: element,
        };
    },
    cesiumProps: cesiumProps$1,
});

var cesiumProps$2 = [
    "image",
    "show",
    "scale",
    "horizontalOrigin",
    "verticalOrigin",
    "eyeOffset",
    "pixelOffset",
    "rotation",
    "alignedAxis",
    "width",
    "height",
    "color",
    "scaleByDistance",
    "translucencyByDistance",
    "pixelOffsetScaleByDistance",
    "imageSubRegion",
    "sizeInMeters",
    "heightReference",
    "distanceDisplayCondition",
    "disableDepthTestDistance",
];
var cesiumEventProps = {
    onDefinitionChange: "definitionChanged",
};
var BillboardGraphics = createCesiumComponent({
    name: "BillboardGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new BillboardGraphics$1({
            image: props.image,
            show: props.show,
            scale: props.scale,
            horizontalOrigin: props.horizontalOrigin,
            verticalOrigin: props.verticalOrigin,
            eyeOffset: props.eyeOffset,
            pixelOffset: props.pixelOffset,
            rotation: props.rotation,
            alignedAxis: props.alignedAxis,
            width: props.width,
            height: props.height,
            color: props.color,
            scaleByDistance: props.scaleByDistance,
            translucencyByDistance: props.translucencyByDistance,
            pixelOffsetScaleByDistance: props.pixelOffsetScaleByDistance,
            imageSubRegion: props.imageSubRegion,
            sizeInMeters: props.sizeInMeters,
            heightReference: props.heightReference,
            distanceDisplayCondition: props.distanceDisplayCondition,
            disableDepthTestDistance: props.disableDepthTestDistance,
        });
        context.entity.billboard = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.billboard = undefined;
        }
    },
    cesiumProps: cesiumProps$2,
    cesiumEventProps: cesiumEventProps,
});

var cesiumProps$3 = [
    "heightReference",
    "dimensions",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "shadows",
    "distanceDisplayCondition",
];
var cesiumEventProps$1 = {
    onDefinitionChange: "definitionChanged",
};
var BoxGraphics = createCesiumComponent({
    name: "BoxGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new BoxGraphics$1({
            heightReference: props.heightReference,
            dimensions: props.dimensions,
            show: props.show,
            fill: props.fill,
            material: props.material,
            outline: props.outline,
            outlineColor: props.outlineColor,
            outlineWidth: props.outlineWidth,
            shadows: props.shadows,
            distanceDisplayCondition: props.distanceDisplayCondition,
        });
        context.entity.box = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.box = undefined;
        }
    },
    cesiumProps: cesiumProps$3,
    cesiumEventProps: cesiumEventProps$1,
});

var cesiumProps$4 = [
    "position",
    "direction",
    "up",
    "right",
    "frustum",
    "defaultMoveAmount",
    "defaultLookAmount",
    "defaultRotateAmount",
    "defaultZoomAmount",
    "constrainedAxis",
    "maximumTranslateFactor",
    "maximumZoomFactor",
    "percentageChanged",
];
var cesiumEventProps$2 = {
    onChange: "changed",
    onMoveEnd: "moveEnd",
    onMoveStart: "moveStart",
};
var Camera = createCesiumComponent({
    name: "Camera",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.camera; },
    cesiumProps: cesiumProps$4,
    cesiumEventProps: cesiumEventProps$2,
    setCesiumPropsAfterCreate: true,
});

var CameraFlyHome = createCameraOperation("CameraFlyHome",
function (camera, _a) {
    var cancelFlightOnUnmount = _a.cancelFlightOnUnmount, duration = _a.duration;
    camera.flyHome(duration);
});

var CameraFlyTo = createCameraOperation("CameraFlyTo",
function (camera, _a) {
    var cancelFlightOnUnmount = _a.cancelFlightOnUnmount, props = __rest(_a, ["cancelFlightOnUnmount"]);
    camera.flyTo(props);
});

var CameraFlyToBoundingSphere = createCameraOperation("CameraFlyToBoundingSphere",
function (camera, _a) {
    var cancelFlightOnUnmount = _a.cancelFlightOnUnmount, boundingSphere = _a.boundingSphere, props = __rest(_a, ["cancelFlightOnUnmount", "boundingSphere"]);
    camera.flyToBoundingSphere(boundingSphere, props);
});

var cesiumProps$5 = [
    "show",
    "modelMatrix",
    "shadows",
    "maximumScreenSpaceError",
    "maximumMemoryUsage",
    "cullRequestsWhileMoving",
    "cullRequestsWhileMovingMultiplier",
    "preloadWhenHidden",
    "preloadFlightDestinations",
    "preferLeaves",
    "progressiveResolutionHeightFraction",
    "foveatedScreenSpaceError",
    "foveatedConeSize",
    "foveatedMinimumScreenSpaceErrorRelaxation",
    "foveatedInterpolationCallback",
    "foveatedTimeDelay",
    "cullWithChildrenBounds",
    "dynamicScreenSpaceError",
    "dynamicScreenSpaceErrorDensity",
    "dynamicScreenSpaceErrorFactor",
    "dynamicScreenSpaceErrorHeightFalloff",
    "skipLevelOfDetail",
    "baseScreenSpaceError",
    "skipScreenSpaceErrorFactor",
    "skipLevels",
    "immediatelyLoadDesiredLevelOfDetail",
    "loadSiblings",
    "clippingPlanes",
    "classificationType",
    "ellipsoid",
    "imageBasedLightingFactor",
    "lightColor",
    "debugFreezeFrame",
    "debugColorizeTiles",
    "debugWireframe",
    "debugShowBoundingVolume",
    "debugShowContentBoundingVolume",
    "debugShowViewerRequestVolume",
    "debugShowGeometricError",
    "debugShowRenderingStatistics",
    "debugShowMemoryUsage",
    "debugShowUrl",
    "colorBlendAmount",
    "colorBlendMode",
    "luminanceAtZenith",
    "sphericalHarmonicCoefficients",
    "specularEnvironmentMaps",
];
var cesiumReadonlyProps = [
    "url",
    "pointCloudShading",
];
var cesiumEventProps$3 = {
    onAllTilesLoad: "allTilesLoaded",
    onInitialTilesLoad: "initialTilesLoaded",
    onLoadProgress: "loadProgress",
    onTileFailed: "tileFailed",
    onTileLoad: "tileLoad",
    onTileUnload: "tileUnload",
    onTileVisible: "tileVisible",
};
var Cesium3DTileset = createCesiumComponent({
    name: "Cesium3DTileset",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new Cesium3DTileset$1(props);
        if (props.colorBlendAmount) {
            element.colorBlendAmount = props.colorBlendAmount;
        }
        if (props.colorBlendMode) {
            element.colorBlendMode = props.colorBlendMode;
        }
        if (props.onReady) {
            element.readyPromise.then(props.onReady);
        }
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$5,
    cesiumReadonlyProps: cesiumReadonlyProps,
    cesiumEventProps: cesiumEventProps$3,
    useCommonEvent: true,
});

var cesiumProps$6 = [
    "resolutionScale",
    "useDefaultRenderLoop",
    "targetFrameRate",
    "useBrowserRecommendedResolution",
];
var cesiumReadonlyProps$1 = [
    "clock",
    "imageryProvider",
    "terrainProvider",
    "skyBox",
    "skyAtmosphere",
    "sceneMode",
    "scene3DOnly",
    "orderIndependentTranslucency",
    "mapMode2D",
    "mapProjection",
    "globe",
    "showRenderLoopErrors",
    "contextOptions",
    "creditContainer",
    "creditViewport",
    "terrainExaggeration",
    "shadows",
    "terrainShadows",
    "requestRenderMode",
    "maximumRenderTimeChange",
];
var CesiumWidget = createCesiumComponent({
    name: "CesiumWidget",
    create: function (context, props, container) {
        if (!container)
            return;
        var v = new CesiumWidget$1(container, pick(props, __spreadArrays(cesiumProps$6, cesiumReadonlyProps$1)));
        if (!v)
            return;
        if (typeof props.resolutionScale === "number") {
            v.resolutionScale = props.resolutionScale;
        }
        var eventManager = new EventManager(v.scene);
        return [v, eventManager];
    },
    destroy: function (element, context, ref, state) {
        if (state && !state.isDestroyed()) {
            state.destroy();
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element, props, state) {
        var _a;
        return _a = {
                cesiumWidget: element,
                scene: element.scene,
                camera: element.scene.camera,
                imageryLayerCollection: element.scene.globe.imageryLayers,
                primitiveCollection: element.scene.primitives,
                globe: element.scene.globe
            },
            _a[eventManagerContextKey] = state,
            _a;
    },
    containerProps: function (_a) {
        var id = _a.id, className = _a.className, style = _a.style, full = _a.full, containerProps = _a.containerProps;
        return (__assign({ className: className,
            id: id, style: __assign(__assign({}, (full
                ? {
                    position: "absolute",
                    bottom: "0",
                    left: "0",
                    right: "0",
                    top: "0",
                }
                : {})), style) }, containerProps));
    },
    cesiumProps: cesiumProps$6,
    cesiumReadonlyProps: cesiumReadonlyProps$1,
    renderContainer: true,
    useCommonEvent: true,
    useRootEvent: true,
});

var cesiumEventProps$4 = {
    onStop: "onStop",
    onTick: "onTick",
};
var cesiumProps$7 = [
    "canAnimate",
    "clockRange",
    "clockStep",
    "currentTime",
    "multiplier",
    "shouldAnimate",
    "startTime",
    "stopTime",
];
var Clock = createCesiumComponent({
    name: "Clock",
    create: function (ctx) { var _a; return (_a = ctx.cesiumWidget) === null || _a === void 0 ? void 0 : _a.clock; },
    cesiumProps: cesiumProps$7,
    cesiumEventProps: cesiumEventProps$4,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$8 = [
    "positions",
    "width",
    "cornerType",
    "height",
    "heightReference",
    "extrudedHeight",
    "extrudedHeightReference",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "granularity",
    "shadows",
    "distanceDisplayCondition",
    "zIndex",
    "classificationType",
];
var cesiumEventProps$5 = {
    onDefinitionChange: "definitionChanged",
};
var CorridorGraphics = createCesiumComponent({
    name: "CorridorGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new CorridorGraphics$1(props);
        if (props.classificationType) {
            element.classificationType = props.classificationType;
        }
        context.entity.corridor = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.corridor = undefined;
        }
    },
    cesiumProps: cesiumProps$8,
    cesiumEventProps: cesiumEventProps$5,
});

var cesiumProps$9 = ["clustering", "name", "show", "clock"];
var cesiumEventProps$6 = {
    onChange: "changedEvent",
    onError: "ErrorEvent",
    onLoading: "loadingEvent",
};
var CustomDataSource = createCesiumComponent({
    name: "CustomDataSource",
    create: function (context, props) {
        if (!context.dataSourceCollection)
            return;
        var element = new CustomDataSource$1(props.name);
        if (props.clustering) {
            element.clustering = props.clustering;
        }
        if (typeof props.show === "boolean") {
            element.show = props.show;
        }
        if (typeof props.clock !== "undefined") {
            element.clock = props.clock;
        }
        context.dataSourceCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.dataSourceCollection && !context.dataSourceCollection.isDestroyed()) {
            context.dataSourceCollection.remove(element);
        }
    },
    provide: function (element) {
        return {
            entityCollection: element.entities,
            dataSource: element,
        };
    },
    cesiumProps: cesiumProps$9,
    cesiumEventProps: cesiumEventProps$6,
});

var cesiumProps$a = [
    "heightReference",
    "length",
    "topRadius",
    "bottomRadius",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "numberOfVerticalLines",
    "slices",
    "shadowMode",
    "distanceDisplayCondition",
];
var cesiumEventProps$7 = {
    onDefinitionChange: "definitionChanged",
};
var CylinderGraphics = createCesiumComponent({
    name: "CylinderGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new CylinderGraphics$1(props);
        context.entity.cylinder = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.cylinder = undefined;
        }
    },
    cesiumProps: cesiumProps$a,
    cesiumEventProps: cesiumEventProps$7,
});

var cesiumProps$b = ["clustering"];
var cesiumReadonlyProps$2 = ["name"];
var cesiumEventProps$8 = {
    onChange: "changedEvent",
    onError: "ErrorEvent",
    onLoading: "loadingEvent",
};
var load = function (_a) {
    var element = _a.element, data = _a.data, onLoad = _a.onLoad, sourceUri = _a.sourceUri, credit = _a.credit;
    element
        .load(data, {
        sourceUri: sourceUri,
        credit: credit,
    })
        .then(function (value) {
        if (onLoad) {
            onLoad(value);
        }
    });
};
var CzmlDataSource = createCesiumComponent({
    name: "CzmlDataSource",
    create: function (context, props) {
        if (!context.dataSourceCollection)
            return;
        var element = new CzmlDataSource$1(props.name);
        if (props.clustering) {
            element.clustering = props.clustering;
        }
        if (typeof props.show === "boolean") {
            element.show = props.show;
        }
        context.dataSourceCollection.add(element);
        if (props.data) {
            load({
                element: element,
                dataSources: context.dataSourceCollection,
                data: props.data,
                onLoad: props.onLoad,
                sourceUri: props.sourceUri,
                credit: props.credit,
            });
        }
        return element;
    },
    update: function (element, props, prevProps, context) {
        if (!props.data) {
            element.show = false;
        }
        else if (prevProps.show !== props.show) {
            element.show = typeof props.show === "boolean" ? props.show : true;
        }
        if (context.dataSourceCollection &&
            props.data &&
            (prevProps.data !== props.data ||
                prevProps.sourceUri !== props.sourceUri ||
                prevProps.credit !== props.credit)) {
            load({
                element: element,
                dataSources: context.dataSourceCollection,
                data: props.data,
                onLoad: props.onLoad,
                sourceUri: props.sourceUri,
                credit: props.credit,
            });
        }
    },
    destroy: function (element, context) {
        if (context.dataSourceCollection && !context.dataSourceCollection.isDestroyed()) {
            context.dataSourceCollection.remove(element);
        }
    },
    provide: function (element) {
        return {
            dataSource: element,
        };
    },
    cesiumProps: cesiumProps$b,
    cesiumReadonlyProps: cesiumReadonlyProps$2,
    cesiumEventProps: cesiumEventProps$8,
});

var cesiumProps$c = [
    "semiMajorAxis",
    "semiMinorAxis",
    "height",
    "heightReference",
    "extrudedHeight",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "numberOfVerticalLines",
    "rotation",
    "stRotation",
    "granularity",
    "shadows",
    "distanceDisplayCondition",
    "zIndex",
    "classificationType",
];
var cesiumEventProps$9 = {
    onDefinitionChange: "definitionChanged",
};
var EllipseGraphics = createCesiumComponent({
    name: "EllipseGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new EllipseGraphics$1(props);
        if (props.classificationType) {
            element.classificationType = props.classificationType;
        }
        context.entity.ellipse = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.ellipse = undefined;
        }
    },
    cesiumProps: cesiumProps$c,
    cesiumEventProps: cesiumEventProps$9,
});

var cesiumProps$d = [
    "heightReference",
    "radii",
    "show",
    "fill",
    "innerRadii",
    "material",
    "maximumClock",
    "maximumCone",
    "minimumClock",
    "minimumCone",
    "outline",
    "outlineColor",
    "outlineWidth",
    "subdivisions",
    "stackPartitions",
    "slicePartitions",
    "shadows",
    "distanceDisplayCondition",
];
var cesiumEventProps$a = {
    onDefinitionChange: "definitionChanged",
};
var EllipsoidGraphics = createCesiumComponent({
    name: "EllipsoidGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new EllipsoidGraphics$1(props);
        context.entity.ellipsoid = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.ellipsoid = undefined;
        }
    },
    cesiumProps: cesiumProps$d,
    cesiumEventProps: cesiumEventProps$a,
});

var cesiumProps$e = [
    "availability",
    "billboard",
    "box",
    "corridor",
    "cylinder",
    "description",
    "ellipse",
    "ellipsoid",
    "label",
    "model",
    "name",
    "orientation",
    "path",
    "plane",
    "point",
    "polygon",
    "polyline",
    "polylineVolume",
    "position",
    "properties",
    "rectangle",
    "show",
    "viewFrom",
    "wall",
];
var cesiumReadonlyProps$3 = ["id"];
var cesiumEventProps$b = {
    onDefinitionChange: "definitionChanged",
};
var Entity = createCesiumComponent({
    name: "Entity",
    create: function (context, props) {
        if (!context.entityCollection)
            return;
        var element = new Entity$1(props);
        if (context.viewer && props.selected) {
            context.viewer.selectedEntity = element;
        }
        if (context.viewer && props.tracked) {
            context.viewer.trackedEntity = element;
        }
        context.entityCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.entityCollection) {
            context.entityCollection.remove(element);
        }
    },
    update: function (element, props, prevProps, context) {
        if (context.viewer) {
            if (props.selected !== prevProps.selected) {
                if (props.selected) {
                    context.viewer.selectedEntity = element;
                }
                else if (context.viewer.selectedEntity === element) {
                    context.viewer.selectedEntity = undefined;
                }
            }
            if (props.tracked !== prevProps.tracked) {
                if (props.tracked) {
                    context.viewer.trackedEntity = element;
                }
                else if (context.viewer.trackedEntity === element) {
                    context.viewer.trackedEntity = undefined;
                }
            }
        }
    },
    provide: function (element) {
        return {
            entity: element,
        };
    },
    cesiumProps: cesiumProps$e,
    cesiumReadonlyProps: cesiumReadonlyProps$3,
    cesiumEventProps: cesiumEventProps$b,
    useCommonEvent: true,
});

var EntityDescription = function (_a) {
    var children = _a.children, container = _a.container, _b = _a.resizeInfoBox, resizeInfoBox = _b === void 0 ? true : _b;
    var _c = useCesium(), viewer = _c.viewer, entity = _c.entity;
    var _d = useState(false), selected = _d[0], setSelected = _d[1];
    var c = useMemo(function () { var _a, _b; return (container !== null && container !== void 0 ? container : (_b = (_a = viewer) === null || _a === void 0 ? void 0 : _a.infoBox.frame.contentDocument) === null || _b === void 0 ? void 0 : _b.createElement("div")); }, [container, viewer]);
    useEffect(function () {
        if (!viewer || !entity)
            return;
        var ev = function (e) {
            setSelected(!!e && e.id === entity.id);
        };
        viewer.selectedEntityChanged.addEventListener(ev);
        return function () {
            viewer.selectedEntityChanged.removeEventListener(ev);
        };
    }, [entity, viewer]);
    useEffect(function () {
        var _a, _b, _c;
        if (container || !c || !viewer)
            return;
        var frame = (_a = viewer.infoBox) === null || _a === void 0 ? void 0 : _a.frame;
        var parent = (_c = (_b = frame) === null || _b === void 0 ? void 0 : _b.contentDocument) === null || _c === void 0 ? void 0 : _c.querySelector(".cesium-infoBox-description");
        if (!frame || !parent)
            return;
        if (selected) {
            parent.appendChild(c);
            if (resizeInfoBox) {
                frame.style.display = "block";
                frame.style.height = parent.getBoundingClientRect().height + "px";
                delete frame.style.display;
            }
        }
        else if (c.parentElement === parent) {
            parent.removeChild(c);
        }
    }, [c, container, resizeInfoBox, selected, viewer]);
    return c ? createPortal(!container || selected ? children : null, c) : null;
};

var renderToStaticMarkup = require("react-dom/server.browser").renderToStaticMarkup;
var EntityStaticDescription = function (_a) {
    var children = _a.children;
    var entity = useCesium().entity;
    useEffect(function () {
        if (!entity || !children)
            return;
        entity.description = new ConstantProperty(renderToStaticMarkup(children));
        return function () {
            if (!entity)
                return;
            entity.description = undefined;
        };
    }, [children, entity]);
    return null;
};

var cesiumProps$f = [
    "density",
    "enabled",
    "minimumBrightness",
    "screenSpaceErrorFactor",
];
var Fog = createCesiumComponent({
    name: "Fog",
    create: function (context) {
        if (!context.scene)
            return;
        var element = new Fog$1();
        context.scene.fog = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.scene && !context.scene.isDestroyed()) {
            context.scene.fog = new Fog$1();
        }
    },
    cesiumProps: cesiumProps$f,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$g = ["clustering", "name"];
var cesiumEventProps$c = {
    onChange: "changedEvent",
    onError: "ErrorEvent",
    onLoading: "loadingEvent",
};
var load$1 = function (_a) {
    var element = _a.element, data = _a.data, onLoad = _a.onLoad, clampToGround = _a.clampToGround, sourceUri = _a.sourceUri, credit = _a.credit, markerSize = _a.markerSize, markerSymbol = _a.markerSymbol, markerColor = _a.markerColor, stroke = _a.stroke, strokeWidth = _a.strokeWidth, fill = _a.fill, describe = _a.describe;
    element
        .load(data, {
        clampToGround: clampToGround,
        markerSize: markerSize,
        markerSymbol: markerSymbol,
        markerColor: markerColor,
        stroke: stroke,
        strokeWidth: strokeWidth,
        fill: fill,
        sourceUri: sourceUri,
        describe: describe,
        credit: credit,
    })
        .then(function (value) {
        if (onLoad) {
            onLoad(value);
        }
    });
};
var GeoJsonDataSource = createCesiumComponent({
    name: "GeoJsonDataSource",
    create: function (context, props) {
        if (!context.dataSourceCollection)
            return;
        var element = new GeoJsonDataSource$1(props.name);
        if (props.clustering) {
            element.clustering = props.clustering;
        }
        if (typeof props.show === "boolean") {
            element.show = props.show;
        }
        context.dataSourceCollection.add(element);
        if (props.data) {
            load$1({
                element: element,
                dataSources: context.dataSourceCollection,
                data: props.data,
                onLoad: props.onLoad,
                clampToGround: props.clampToGround,
                sourceUri: props.sourceUri,
                markerSize: props.markerSize,
                markerSymbol: props.markerSymbol,
                markerColor: props.markerColor,
                stroke: props.stroke,
                strokeWidth: props.strokeWidth,
                fill: props.fill,
                describe: props.describe,
                credit: props.credit,
            });
        }
        return element;
    },
    update: function (element, props, prevProps, context) {
        if (!props.data) {
            element.show = false;
        }
        else if (prevProps.show !== props.show) {
            element.show = typeof props.show === "boolean" ? props.show : true;
        }
        if (context.dataSourceCollection &&
            props.data &&
            (prevProps.data !== props.data ||
                prevProps.clampToGround !== props.clampToGround ||
                prevProps.sourceUri !== props.sourceUri ||
                prevProps.credit !== props.credit ||
                prevProps.markerSize !== props.markerSize ||
                prevProps.markerSymbol !== props.markerSymbol ||
                prevProps.markerColor !== props.markerColor ||
                prevProps.stroke !== props.stroke ||
                prevProps.strokeWidth !== props.strokeWidth ||
                prevProps.fill !== props.fill)) {
            load$1({
                element: element,
                dataSources: context.dataSourceCollection,
                data: props.data,
                onLoad: props.onLoad,
                clampToGround: props.clampToGround,
                sourceUri: props.sourceUri,
                credit: props.credit,
                markerSize: props.markerSize,
                markerSymbol: props.markerSymbol,
                markerColor: props.markerColor,
                stroke: props.stroke,
                strokeWidth: props.strokeWidth,
                fill: props.fill,
                describe: props.describe,
            });
        }
    },
    destroy: function (element, context) {
        if (context.dataSourceCollection && !context.dataSourceCollection.isDestroyed()) {
            context.dataSourceCollection.remove(element);
        }
    },
    provide: function (element) {
        return {
            dataSource: element,
        };
    },
    cesiumProps: cesiumProps$g,
    cesiumEventProps: cesiumEventProps$c,
});

var cesiumEventProps$d = {
    onImageryLayersUpdate: "imageryLayersUpdatedEvent",
    onTerrainProviderChange: "terrainProviderChanged",
    onTileLoadProgress: "tileLoadProgressEvent",
};
var cesiumProps$h = [
    "atmosphereBrightnessShift",
    "atmosphereHueShift",
    "atmosphereSaturationShift",
    "backFaceCulling",
    "baseColor",
    "clippingPlanes",
    "depthTestAgainstTerrain",
    "enableLighting",
    "lightingFadeInDistance",
    "lightingFadeOutDistance",
    "material",
    "maximumScreenSpaceError",
    "nightFadeInDistance",
    "nightFadeOutDistance",
    "oceanNormalMapUrl",
    "shadows",
    "show",
    "showGroundAtmosphere",
    "showWaterEffect",
    "terrainProvider",
    "tileCacheSize",
];
var Globe = createCesiumComponent({
    name: "Globe",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.globe; },
    cesiumProps: cesiumProps$h,
    cesiumEventProps: cesiumEventProps$d,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$i = [
    "appearance",
    "classificationType",
    "debugShowBoundingVolume",
    "debugShowShadowVolume",
    "depthFailAppearance",
    "show",
];
var cesiumReadonlyProps$4 = [
    "allowPicking",
    "asynchronous",
    "compressVertices",
    "geometryInstances",
    "interleave",
    "releaseGeometryInstances",
    "vertexCacheOptimize",
];
var GroundPrimitive = createCesiumComponent({
    name: "GroundPrimitive",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new GroundPrimitive$1(props);
        if (props.onReady) {
            element.readyPromise.then(props.onReady);
        }
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$i,
    cesiumReadonlyProps: cesiumReadonlyProps$4,
    useCommonEvent: true,
});

var cesiumProps$j = ["show"];
var GroundPrimitiveCollection = createCesiumComponent({
    name: "GroundPrimitiveCollection",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.groundPrimitives; },
    provide: function (element) { return ({
        primitiveCollection: element,
    }); },
    cesiumProps: cesiumProps$j,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$k = [
    "alpha",
    "brightness",
    "contrast",
    "hue",
    "saturation",
    "gamma",
    "splitDirection",
    "minificationFilter",
    "magnificationFilter",
    "cutoutRectangle",
    "show",
];
var cesiumReadonlyProps$5 = [
    "imageryProvider",
    "rectangle",
    "maximumAnisotropy",
    "minimumTerrainLevel",
    "maximumTerrainLevel",
];
var ImageryLayer = createCesiumComponent({
    name: "ImageryLayer",
    create: function (context, props) {
        if (!context.imageryLayerCollection)
            return;
        var element = new ImageryLayer$1(props.imageryProvider, {
            rectangle: props.rectangle,
            alpha: props.alpha,
            brightness: props.brightness,
            contrast: props.contrast,
            hue: props.hue,
            saturation: props.saturation,
            gamma: props.gamma,
            splitDirection: props.splitDirection,
            minificationFilter: props.minificationFilter,
            magnificationFilter: props.magnificationFilter,
            show: props.show,
            maximumAnisotropy: props.maximumAnisotropy,
            minimumTerrainLevel: props.minimumTerrainLevel,
            maximumTerrainLevel: props.maximumTerrainLevel,
            cutoutRectangle: props.cutoutRectangle,
        });
        context.imageryLayerCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.imageryLayerCollection) {
            context.imageryLayerCollection.remove(element);
        }
    },
    cesiumProps: cesiumProps$k,
    cesiumReadonlyProps: cesiumReadonlyProps$5,
});

var cesiumEventProps$e = {
    onLayerAdd: "layerAdded",
    onLayerMove: "layerMoved",
    onLayerRemove: "layerRemoved",
    onLayerShowOrHide: "layerShownOrHidden",
};
var ImageryLayerCollection = createCesiumComponent({
    name: "ImageryLayerCollection",
    create: function (context) { var _a; return (_a = context.globe) === null || _a === void 0 ? void 0 : _a.imageryLayers; },
    cesiumEventProps: cesiumEventProps$e,
});

var cesiumProps$l = ["clustering", "name"];
var cesiumReadonlyProps$6 = [
    "camera",
    "canvas",
    "ellipsoid",
];
var cesiumEventProps$f = {
    onChange: "changedEvent",
    onError: "ErrorEvent",
    onLoading: "loadingEvent",
    onRefresh: "refreshEvent",
    onUnsupportedNode: "unsupportedNodeEvent",
};
var load$2 = function (_a) {
    var element = _a.element, data = _a.data, onLoad = _a.onLoad, clampToGround = _a.clampToGround, ellipsoid = _a.ellipsoid, sourceUri = _a.sourceUri, credit = _a.credit;
    element.load(data, { clampToGround: clampToGround, ellipsoid: ellipsoid, sourceUri: sourceUri, credit: credit }).then(function (value) {
        if (onLoad) {
            onLoad(value);
        }
    });
};
var KmlDataSource = createCesiumComponent({
    name: "KmlDataSource",
    create: function (context, props) {
        if (!context.scene || !context.dataSourceCollection)
            return;
        var element = new KmlDataSource$1({
            camera: props.camera || context.scene.camera,
            canvas: props.canvas || context.scene.canvas,
            ellipsoid: props.ellipsoid,
        });
        if (props.clustering) {
            element.clustering = props.clustering;
        }
        if (typeof props.show === "boolean") {
            element.show = props.show;
        }
        if (typeof props.name !== "undefined") {
            element.name = props.name;
        }
        context.dataSourceCollection.add(element);
        if (props.data) {
            load$2({
                element: element,
                dataSources: context.dataSourceCollection,
                data: props.data,
                onLoad: props.onLoad,
                clampToGround: props.clampToGround,
                ellipsoid: props.ellipsoid,
                sourceUri: props.sourceUri,
                credit: props.credit,
            });
        }
        return element;
    },
    update: function (element, props, prevProps, context) {
        if (!props.data) {
            element.show = false;
        }
        else if (prevProps.show !== props.show) {
            element.show = typeof props.show === "boolean" ? props.show : true;
        }
        if (context.dataSourceCollection &&
            props.data &&
            (prevProps.data !== props.data ||
                prevProps.clampToGround !== props.clampToGround ||
                prevProps.ellipsoid !== props.ellipsoid ||
                prevProps.sourceUri !== props.sourceUri ||
                prevProps.credit !== prevProps.credit)) {
            load$2({
                element: element,
                dataSources: context.dataSourceCollection,
                data: props.data,
                onLoad: props.onLoad,
                clampToGround: props.clampToGround,
                ellipsoid: props.ellipsoid,
                sourceUri: props.sourceUri,
                credit: props.credit,
            });
        }
    },
    destroy: function (element, context) {
        if (context.dataSourceCollection && !context.dataSourceCollection.isDestroyed()) {
            context.dataSourceCollection.remove(element);
        }
    },
    provide: function (element) {
        return {
            dataSource: element,
        };
    },
    cesiumProps: cesiumProps$l,
    cesiumReadonlyProps: cesiumReadonlyProps$6,
    cesiumEventProps: cesiumEventProps$f,
});

var cesiumProps$m = [
    "backgroundColor",
    "backgroundPadding",
    "disableDepthTestDistance",
    "distanceDisplayCondition",
    "eyeOffset",
    "fillColor",
    "font",
    "heightReference",
    "horizontalOrigin",
    "id",
    "outlineColor",
    "outlineWidth",
    "pixelOffset",
    "pixelOffsetScaleByDistance",
    "position",
    "scale",
    "scaleByDistance",
    "show",
    "showBackground",
    "style",
    "text",
    "translucencyByDistance",
    "verticalOrigin",
];
var Label = createCesiumComponent({
    name: "Label",
    create: function (context, props) { var _a; return (_a = context.labelCollection) === null || _a === void 0 ? void 0 : _a.add(props); },
    destroy: function (element, context) {
        if (context.labelCollection && !context.labelCollection.isDestroyed()) {
            context.labelCollection.remove(element);
        }
    },
    cesiumProps: cesiumProps$m,
    useCommonEvent: true,
});

var cesiumProps$n = [
    "blendOption",
    "debugShowBoundingVolume",
    "modelMatrix",
];
var LabelCollection = createCesiumComponent({
    name: "LabelCollection",
    create: function (context, props) {
        if (!context.scene || !context.primitiveCollection)
            return;
        var element = new LabelCollection$1({
            scene: context.scene,
            modelMatrix: props.modelMatrix,
            blendOption: props.blendOption,
            debugShowBoundingVolume: props.debugShowBoundingVolume,
        });
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element) {
        return {
            labelCollection: element,
        };
    },
    cesiumProps: cesiumProps$n,
});

var cesiumProps$o = [
    "text",
    "font",
    "style",
    "fillColor",
    "outlineColor",
    "outlineWidth",
    "show",
    "showBackground",
    "backgroundColor",
    "backgroundPadding",
    "scale",
    "horizontalOrigin",
    "verticalOrigin",
    "eyeOffset",
    "pixelOffset",
    "translucencyByDistance",
    "pixelOffsetScaleByDistance",
    "scaleByDistance",
    "heightReference",
    "distanceDisplayCondition",
    "disableDepthTestDistance",
];
var cesiumEventProps$g = {
    onDefinitionChange: "definitionChanged",
};
var LabelGraphics = createCesiumComponent({
    name: "LabelGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new LabelGraphics$1(props);
        context.entity.label = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.label = undefined;
        }
    },
    cesiumProps: cesiumProps$o,
    cesiumEventProps: cesiumEventProps$g,
});

var cesiumProps$p = [
    "basePath",
    "clampAnimations",
    "clippingPlanes",
    "color",
    "colorBlendAmount",
    "colorBlendMode",
    "debugShowBoundingVolume",
    "debugWireframe",
    "dequantizeInShader",
    "distanceDisplayCondition",
    "id",
    "imageBasedLightingFactor",
    "lightColor",
    "maximumScale",
    "minimumPixelSize",
    "modelMatrix",
    "scale",
    "scene",
    "shadows",
    "show",
    "silhouetteColor",
    "silhouetteSize",
    "luminanceAtZenith",
    "sphericalHarmonicCoefficients",
    "specularEnvironmentMaps",
];
var cesiumReadonlyProps$7 = [
    "allowPicking",
    "asynchronous",
    "gltf",
    "incrementallyLoadTextures",
    "url",
    "credit",
];
var Model = createCesiumComponent({
    name: "Model",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = props.url ? Model$1.fromGltf(props) : new Model$1(props);
        if (props.onReady) {
            element.readyPromise.then(props.onReady);
        }
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$p,
    cesiumReadonlyProps: cesiumReadonlyProps$7,
    useCommonEvent: true,
});

var cesiumProps$q = [
    "uri",
    "show",
    "scale",
    "minimumPixelSize",
    "maximumScale",
    "incrementallyLoadTextures",
    "runAnimations",
    "clampAnimations",
    "nodeTransformations",
    "shadows",
    "heightReference",
    "distanceDisplayCondition",
    "silhouetteColor",
    "silhouetteSize",
    "color",
    "colorBlendMode",
    "colorBlendAmount",
    "clippingPlanes",
    "imageBasedLightingFactor",
    "lightColor",
];
var cesiumEventProps$h = {
    onDefinitionChange: "definitionChanged",
};
var ModelGraphics = createCesiumComponent({
    name: "ModelGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new ModelGraphics$1(props);
        context.entity.model = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.model = undefined;
        }
    },
    cesiumProps: cesiumProps$q,
    cesiumEventProps: cesiumEventProps$h,
});

var cesiumProps$r = ["onlySunLighting", "show", "textureUrl"];
var cesiumReadonlyProps$8 = ["ellipsoid"];
var Moon = createCesiumComponent({
    name: "Moon",
    create: function (context, props) {
        if (!context.scene)
            return;
        var element = new Moon$1(props);
        context.scene.moon = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.scene && !context.scene.isDestroyed()) {
            context.scene.moon = new Moon$1();
        }
    },
    cesiumProps: cesiumProps$r,
    cesiumReadonlyProps: cesiumReadonlyProps$8,
});

var cesiumProps$s = [
    "show",
    "emitter",
    "modelMatrix",
    "emitterModelMatrix",
    "emissionRate",
    "bursts",
    "loop",
    "scale",
    "startScale",
    "endScale",
    "color",
    "startColor",
    "endColor",
    "image",
    "imageSize",
    "minimumImageSize",
    "maximumImageSize",
    "speed",
    "minimumSpeed",
    "maximumSpeed",
    "lifetime",
    "particleLife",
    "minimumParticleLife",
    "maximumParticleLife",
    "mass",
    "minimumMass",
    "maximumMass",
];
var cesiumEventProps$i = {
    onComplete: "complete",
};
var ParticleSystem = createCesiumComponent({
    name: "ParticleSystem",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new ParticleSystem$1(__assign(__assign({}, props), { updateCallback: props.onUpdate }));
        context.primitiveCollection.add(element);
        return element;
    },
    update: function (element, props, prevProps) {
        if (props.onUpdate !== prevProps.onUpdate) {
            element.updateCallback = props.onUpdate;
        }
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed) {
            context.primitiveCollection.remove(element);
        }
    },
    cesiumProps: cesiumProps$s,
    cesiumEventProps: cesiumEventProps$i,
});

var cesiumProps$t = [
    "leadTime",
    "trailTime",
    "show",
    "width",
    "material",
    "resolution",
    "distanceDisplayCondition",
];
var cesiumEventProps$j = {
    onDefinitionChange: "definitionChanged",
};
var PathGraphics = createCesiumComponent({
    name: "PathGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new PathGraphics$1(props);
        context.entity.path = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.path = undefined;
        }
    },
    cesiumProps: cesiumProps$t,
    cesiumEventProps: cesiumEventProps$j,
});

var cesiumProps$u = [
    "plane",
    "dimensions",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "shadows",
    "distanceDisplayCondition",
];
var cesiumEventProps$k = {
    onDefinitionChange: "definitionChanged",
};
var PlaneGraphics = createCesiumComponent({
    name: "PlaneGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new PlaneGraphics$1(props);
        context.entity.plane = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.plane = undefined;
        }
    },
    cesiumProps: cesiumProps$u,
    cesiumEventProps: cesiumEventProps$k,
});

var cesiumProps$v = [
    "color",
    "pixelSize",
    "outlineColor",
    "outlineWidth",
    "show",
    "scaleByDistance",
    "translucencyByDistance",
    "heightReference",
    "distanceDisplayCondition",
    "disableDepthTestDistance",
];
var cesiumEventProps$l = {
    onDefinitionChange: "definitionChanged",
};
var PointGraphics = createCesiumComponent({
    name: "PointGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new PointGraphics$1(props);
        context.entity.point = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.point = undefined;
        }
    },
    cesiumProps: cesiumProps$v,
    cesiumEventProps: cesiumEventProps$l,
});

var cesiumProps$w = [
    "color",
    "disableDepthTestDistance",
    "distanceDisplayCondition",
    "id",
    "outlineColor",
    "outlineWidth",
    "pixelSize",
    "position",
    "scaleByDistance",
    "show",
    "translucencyByDistance",
];
var PointPrimitive = createCesiumComponent({
    name: "PointPrimitive",
    create: function (context, props) { var _a; return (_a = context.pointPrimitiveCollection) === null || _a === void 0 ? void 0 : _a.add(props); },
    destroy: function (element, context) {
        if (context.pointPrimitiveCollection && !context.pointPrimitiveCollection.isDestroyed()) {
            context.pointPrimitiveCollection.remove(element);
        }
    },
    cesiumProps: cesiumProps$w,
    useCommonEvent: true,
});

var cesiumProps$x = [
    "blendOption",
    "debugShowBoundingVolume",
    "modelMatrix",
];
var PointPrimitiveCollection = createCesiumComponent({
    name: "PointPrimitveCollection",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new PointPrimitiveCollection$1(props);
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element) {
        return {
            pointPrimitiveCollection: element,
        };
    },
    cesiumProps: cesiumProps$x,
});

var cesiumProps$y = [
    "hierarchy",
    "height",
    "heightReference",
    "extrudedHeight",
    "extrudedHeightReference",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "stRotation",
    "granularity",
    "perPositionHeight",
    "closeTop",
    "closeBottom",
    "shadows",
    "distanceDisplayCondition",
    "zIndex",
    "classificationType",
];
var cesiumEventProps$m = {
    onDefinitionChange: "definitionChanged",
};
var PolygonGraphics = createCesiumComponent({
    name: "PolygonGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new PolygonGraphics$1(props);
        context.entity.polygon = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.polygon = undefined;
        }
    },
    cesiumProps: cesiumProps$y,
    cesiumEventProps: cesiumEventProps$m,
});

var cesiumProps$z = [
    "distanceDisplayCondition",
    "id",
    "loop",
    "material",
    "positions",
    "show",
    "width",
];
var Polyline = createCesiumComponent({
    name: "Polyline",
    create: function (context, props) { var _a; return (_a = context.polylineCollection) === null || _a === void 0 ? void 0 : _a.add(props); },
    destroy: function (element, context) {
        if (context.polylineCollection && !context.polylineCollection.isDestroyed()) {
            context.polylineCollection.remove(element);
        }
    },
    cesiumProps: cesiumProps$z,
    useCommonEvent: true,
});

var cesiumProps$A = [
    "debugShowBoundingVolume",
    "length",
    "modelMatrix",
];
var PolylineCollection = createCesiumComponent({
    name: "PolylineCollection",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new PolylineCollection$1({
            modelMatrix: props.modelMatrix,
            debugShowBoundingVolume: props.debugShowBoundingVolume,
            length: props.length,
            scene: context.scene,
        });
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element) {
        return {
            polylineCollection: element,
        };
    },
    cesiumProps: cesiumProps$A,
});

var cesiumProps$B = [
    "positions",
    "followSurface",
    "clampToGround",
    "width",
    "show",
    "material",
    "depthFailMaterial",
    "granularity",
    "shadows",
    "distanceDisplayCondition",
    "zIndex",
];
var cesiumEventProps$n = {
    onDefinitionChange: "definitionChanged",
};
var PolylineGraphics = createCesiumComponent({
    name: "PolylineGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new PolylineGraphics$1(props);
        context.entity.polyline = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.polyline = undefined;
        }
    },
    cesiumProps: cesiumProps$B,
    cesiumEventProps: cesiumEventProps$n,
});

var cesiumProps$C = [
    "positions",
    "shape",
    "cornerType",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "granularity",
    "shadows",
    "distanceDisplayCondition",
];
var cesiumEventProps$o = {
    onDefinitionChange: "definitionChanged",
};
var PolylineVolumeGraphics = createCesiumComponent({
    name: "PolylineVolumeGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new PolylineVolumeGraphics$1(props);
        context.entity.polylineVolume = element;
        return element;
    },
    destroy: function (contextelement, context) {
        if (context.entity) {
            context.entity.polylineVolume = undefined;
        }
    },
    cesiumProps: cesiumProps$C,
    cesiumEventProps: cesiumEventProps$o,
});

var cesiumProps$D = ["enabled", "selected"];
var cesiumReadonlyProps$9 = [
    "clearColor",
    "forcePowerOfTwo",
    "fragmentShader",
    "name",
    "pixelDatatype",
    "pixelFormat",
    "sampleMode",
    "scissorRectangle",
    "textureScale",
    "uniforms",
];
var PostProcessStage = createCesiumComponent({
    name: "PostProcessStage",
    create: function (context, props) {
        if (!context.scene)
            return;
        var element = new PostProcessStage$1(props);
        if (typeof props.enabled === "boolean") {
            element.enabled = props.enabled;
        }
        if (props.selected) {
            element.selected = props.selected;
        }
        context.scene.postProcessStages.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.scene && !context.scene.isDestroyed()) {
            context.scene.postProcessStages.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$D,
    cesiumReadonlyProps: cesiumReadonlyProps$9,
});

var cesiumProps$E = ["enabled", "selected"];
var createPostProcessStage = function (opts) {
    return createCesiumComponent({
        name: name,
        create: function (context, props) {
            if (!context.scene)
                return;
            var element = opts.create(props, context.scene.postProcessStages);
            if (typeof props.enabled === "boolean") {
                element.enabled = props.enabled;
            }
            if (props.selected && "selected" in element) {
                element.selected = props.selected;
            }
            opts.props.forEach(function (k) {
                if (!includes(opts.readonlyProps, k) && typeof props[k] !== "undefined") {
                    element.uniforms[k] = props[k];
                }
            });
            if (!opts.noMount && context.scene && !context.scene.isDestroyed()) {
                context.scene.postProcessStages.add(element);
            }
            return element;
        },
        destroy: function (element, context) {
            if (!opts.noMount) {
                if (context.scene && !context.scene.isDestroyed()) {
                    context.scene.postProcessStages.remove(element);
                }
                if (!element.isDestroyed()) {
                    element.destroy();
                }
            }
            else {
                element.enabled = false;
            }
        },
        update: function (element, props, prevProps) {
            opts.props.forEach(function (k) {
                if (!includes(opts.readonlyProps, k) && props[k] !== prevProps[k]) {
                    element.uniforms[k] = props[k];
                }
            });
        },
        cesiumProps: cesiumProps$E,
        cesiumReadonlyProps: opts.readonlyProps,
        defaultProps: {
            enabled: true,
        },
    });
};

var BlackAndWhiteStage = createPostProcessStage({
    name: "BlackAndWhiteStage",
    props: ["gradations"],
    create: function () { return PostProcessStageLibrary.createBlackAndWhiteStage(); },
});

var BrightnessStage = createPostProcessStage({
    name: "BrightnessStage",
    props: ["brightness"],
    create: function () { return PostProcessStageLibrary.createBrightnessStage(); },
});

var LensFlareStage = createPostProcessStage({
    name: "LensFlareStage",
    props: [
        "dirtTexture",
        "starTexture",
        "intensity",
        "distortion",
        "ghostDispersal",
        "haloWidth",
        "earthRadius",
    ],
    create: function () { return PostProcessStageLibrary.createLensFlareStage(); },
});

var Fxaa = createPostProcessStage({
    name: "Fxaa",
    create: function (props, collection) { return collection.fxaa; },
    props: [],
});

var NightVisionStage = createPostProcessStage({
    name: "NightVisionStage",
    props: [],
    create: function () { return PostProcessStageLibrary.createNightVisionStage(); },
});

var cesiumProps$F = ["enabled", "selected"];
var cesiumReadonlyProps$a = [
    "inputPreviousStageTexture",
    "name",
    "stages",
    "uniforms",
];
var PostProcessStageComposite = createCesiumComponent({
    name: "PostProcessStageComposite",
    create: function (context, props) {
        if (!context.scene)
            return;
        var element = new PostProcessStageComposite$1(props);
        if (typeof props.enabled === "boolean") {
            element.enabled = props.enabled;
        }
        if (props.selected) {
            element.selected = props.selected;
        }
        context.scene.postProcessStages.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.scene && !context.scene.isDestroyed()) {
            context.scene.postProcessStages.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$F,
    cesiumReadonlyProps: cesiumReadonlyProps$a,
});

var AmbientOcclusion = createPostProcessStage({
    name: "AmbientOcclusion",
    create: function (props, collection) { return collection.ambientOcclusion; },
    props: [
        "ambientOcclusionOnly",
        "bias",
        "delta",
        "frustumLength",
        "intensity",
        "lengthCap",
        "sigma",
        "stepSize",
    ],
    noMount: true,
});

var Bloom = createPostProcessStage({
    name: "Bloom",
    create: function (props, collection) { return collection.bloom; },
    props: ["brightness", "contrast", "delta", "glowOnly", "sigma", "stepSize"],
    noMount: true,
});

var BlurStage = createPostProcessStage({
    name: "BlurStage",
    props: ["delta", "sigma", "stepSize"],
    create: function () { return PostProcessStageLibrary.createBlurStage(); },
});

var DepthOfFieldStage = createPostProcessStage({
    name: "DepthOfFieldStage",
    props: ["delta", "focalDistance", "sigma", "stepSize"],
    create: function () { return PostProcessStageLibrary.createDepthOfFieldStage(); },
});

var EdgeDetectionStage = createPostProcessStage({
    name: "EdgeDetectionStage",
    props: ["color", "length"],
    create: function () { return PostProcessStageLibrary.createEdgeDetectionStage(); },
});

var SilhouetteStage = createPostProcessStage({
    name: "SilhouetteStage",
    props: ["color", "length"],
    create: function () { return PostProcessStageLibrary.createSilhouetteStage(); },
});

var cesiumProps$G = [
    "appearance",
    "cull",
    "debugShowBoundingVolume",
    "depthFailAppearance",
    "modelMatrix",
    "shadows",
    "show",
];
var cesiumReadonlyProps$b = [
    "allowPicking",
    "asynchronous",
    "compressVertices",
    "geometryInstances",
    "interleave",
    "releaseGeometryInstances",
    "vertexCacheOptimize",
];
var Primitive = createCesiumComponent({
    name: "Primitive",
    create: function (context, props) {
        if (!context.primitiveCollection)
            return;
        var element = new Primitive$1(props);
        if (props.onReady) {
            element.readyPromise.then(props.onReady);
        }
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$G,
    cesiumReadonlyProps: cesiumReadonlyProps$b,
    useCommonEvent: true,
});

var cesiumProps$H = [
    "coordinates",
    "height",
    "heightReference",
    "extrudedHeight",
    "extrudedHeightReference",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "rotation",
    "stRotation",
    "granularity",
    "shadows",
    "distanceDisplayCondition",
    "zIndex",
];
var cesiumEventProps$p = {
    onDefinitionChange: "definitionChanged",
};
var RectangleGraphics = createCesiumComponent({
    name: "RectangleGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new RectangleGraphics$1(props);
        context.entity.rectangle = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.rectangle = undefined;
        }
    },
    cesiumProps: cesiumProps$H,
    cesiumEventProps: cesiumEventProps$p,
});

var cesiumProps$I = [
    "backgroundColor",
    "completeMorphOnUserInput",
    "debugCommandFilter",
    "debugShowCommands",
    "debugShowDepthFrustum",
    "debugShowFramesPerSecond",
    "debugShowFrustumPlanes",
    "debugShowFrustums",
    "debugShowGlobeDepth",
    "eyeSeparation",
    "farToNearRatio",
    "focalLength",
    "fog",
    "fxaa",
    "globe",
    "highDynamicRange",
    "imagerySplitPosition",
    "invertClassification",
    "invertClassificationColor",
    "light",
    "logarithmicDepthBuffer",
    "logarithmicDepthFarToNearRatio",
    "mapMode2D",
    "maximumRenderTimeChange",
    "minimumDisableDepthTestDistance",
    "moon",
    "morphTime",
    "nearToFarDistance2D",
    "pickTranslucentDepth",
    "requestRenderMode",
    "rethrowRenderErrors",
    "shadowMap",
    "skyAtmosphere",
    "skyBox",
    "specularEnvironmentMaps",
    "sphericalHarmonicCoefficients",
    "sun",
    "sunBloom",
    "terrainProvider",
    "useDepthPicking",
    "useWebVR",
];
var cesiumEventProps$q = {
    onMorphComplete: "morphComplete",
    onMorphStart: "morphStart",
    onPostRender: "postRender",
    onPreRender: "preRender",
    onPreUpdate: "preUpdate",
    onRenderError: "renderError",
    onTerrainProviderChange: "terrainProviderChanged",
};
var morph = function (scene, mode, morphTime) {
    switch (mode) {
        case SceneMode.SCENE2D:
            scene.morphTo2D(morphTime);
            break;
        case SceneMode.COLUMBUS_VIEW:
            scene.morphToColumbusView(morphTime);
            break;
        case SceneMode.SCENE3D:
            scene.morphTo3D(morphTime);
            break;
    }
};
var Scene = createCesiumComponent({
    name: "Scene",
    create: function (context, props) {
        if (context.scene && props.mode) {
            morph(context.scene, props.mode, props.morphDuration);
        }
        return context.scene;
    },
    update: function (scene, props, prevProps) {
        if (props.mode !== prevProps.mode && props.mode) {
            morph(scene, props.mode, props.morphDuration);
        }
    },
    cesiumProps: cesiumProps$I,
    cesiumEventProps: cesiumEventProps$q,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$J = [
    "bounceAnimationTime",
    "enableCollisionDetection",
    "enableInputs",
    "enableLook",
    "enableRotate",
    "enableTilt",
    "enableTranslate",
    "enableZoom",
    "inertiaSpin",
    "inertiaTranslate",
    "inertiaZoom",
    "lookEventTypes",
    "maximumMovementRatio",
    "maximumZoomDistance",
    "minimumCollisionTerrainHeight",
    "minimumPickingTerrainHeight",
    "minimumTrackBallHeight",
    "minimumZoomDistance",
    "rotateEventTypes",
    "tiltEventTypes",
    "translateEventTypes",
    "zoomEventTypes",
];
var ScreenSpaceCameraController = createCesiumComponent({
    name: "ScreenSpaceCameraController",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.screenSpaceCameraController; },
    cesiumProps: cesiumProps$J,
    setCesiumPropsAfterCreate: true,
});

var ScreenSpaceEvent = function (_a) {
    var action = _a.action, modifier = _a.modifier, type = _a.type;
    var ctx = useCesium();
    useEffect(function () {
        if (!ctx.screenSpaceEventHandler || ctx.screenSpaceEventHandler.isDestroyed())
            return;
        if (action) {
            ctx.screenSpaceEventHandler.setInputAction(action, type, modifier);
            return function () {
                if (!ctx.screenSpaceEventHandler || ctx.screenSpaceEventHandler.isDestroyed())
                    return;
                ctx.screenSpaceEventHandler.removeInputAction(type, modifier);
            };
        }
        else {
            ctx.screenSpaceEventHandler.removeInputAction(type, modifier);
        }
        return undefined;
    }, [action, ctx.screenSpaceEventHandler, modifier, type]);
    return null;
};

var ScreenSpaceEventHandler = createCesiumComponent({
    name: "ScreenSpaceEventHandler",
    create: function (context, props) {
        var _a;
        return props.useDefault
            ? (_a = context.cesiumWidget) === null || _a === void 0 ? void 0 : _a.screenSpaceEventHandler : context.scene
            ? new ScreenSpaceEventHandler$1(context.scene.canvas)
            : undefined;
    },
    destroy: function (element) {
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element) {
        return {
            screenSpaceEventHandler: element,
        };
    },
});

var cesiumProps$K = [
    "darkness",
    "enabled",
    "maximumDistance",
    "normalOffset",
    "size",
    "softShadows",
];
var ShadowMap = createCesiumComponent({
    name: "ShadowMap",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.shadowMap; },
    cesiumProps: cesiumProps$K,
});

var cesiumProps$L = [
    "brightnessShift",
    "hueShift",
    "saturationShift",
    "show",
];
var SkyAtmosphere = createCesiumComponent({
    name: "SkyAtmosphere",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.skyAtmosphere; },
    cesiumProps: cesiumProps$L,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$M = ["sources", "show"];
var SkyBox = createCesiumComponent({
    name: "SkyBox",
    create: function (context) { var _a; return (_a = context.scene) === null || _a === void 0 ? void 0 : _a.skyBox; },
    cesiumProps: cesiumProps$M,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$N = ["glowFactor", "show"];
var Sun = createCesiumComponent({
    name: "Sun",
    create: function (context) {
        if (!context.scene)
            return;
        var element = new Sun$1();
        context.scene.sun = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.scene && !context.scene.isDestroyed()) {
            context.scene.sun = new Sun$1();
        }
    },
    cesiumProps: cesiumProps$N,
    setCesiumPropsAfterCreate: true,
});

var cesiumProps$O = [
    "clippingPlanes",
    "clock",
    "intervals",
    "maximumMemoryUsage",
    "modelMatrix",
    "shadows",
    "show",
    "style",
];
var cesiumReadonlyProps$c = ["shading"];
var cesiumEventProps$r = {
    onFrameChange: "frameChanged",
};
var TimeDynamicPointCloud = createCesiumComponent({
    name: "TimeDynamicPointCloud",
    create: function (context, props) {
        var _a, _b;
        if (!context.cesiumWidget || !context.primitiveCollection)
            return;
        var element = new TimeDynamicPointCloud$1(__assign(__assign({}, props), { clock: (_a = props.clock, (_a !== null && _a !== void 0 ? _a : (_b = context.cesiumWidget) === null || _b === void 0 ? void 0 : _b.clock)) }));
        if (props.onReady) {
            element.readyPromise.then(props.onReady);
        }
        context.primitiveCollection.add(element);
        return element;
    },
    destroy: function (element, context) {
        if (context.primitiveCollection && !context.primitiveCollection.isDestroyed()) {
            context.primitiveCollection.remove(element);
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    cesiumProps: cesiumProps$O,
    cesiumReadonlyProps: cesiumReadonlyProps$c,
    cesiumEventProps: cesiumEventProps$r,
});

var cesiumProps$P = [
    "terrainProvider",
    "terrainShadows",
    "clockTrackedDataSource",
    "targetFrameRate",
    "useDefaultRenderLoop",
    "resolutionScale",
    "allowDataSourcesToSuspendAnimation",
    "trackedEntity",
    "selectedEntity",
    "shadows",
    "useBrowserRecommendedResolution",
];
var cesiumReadonlyProps$d = [
    "animation",
    "baseLayerPicker",
    "fullscreenButton",
    "vrButton",
    "geocoder",
    "homeButton",
    "infoBox",
    "sceneModePicker",
    "selectionIndicator",
    "timeline",
    "navigationHelpButton",
    "navigationInstructionsInitiallyVisible",
    "scene3DOnly",
    "shouldAnimate",
    "clockViewModel",
    "selectedImageryProviderViewModel",
    "imageryProviderViewModels",
    "selectedTerrainProviderViewModel",
    "terrainProviderViewModels",
    "imageryProvider",
    "skyBox",
    "skyAtmosphere",
    "fullscreenElement",
    "showRenderLoopErrors",
    "automaticallyTrackDataSourceClocks",
    "contextOptions",
    "sceneMode",
    "mapProjection",
    "globe",
    "orderIndependentTranslucency",
    "creditContainer",
    "creditViewport",
    "dataSources",
    "terrainExaggeration",
    "mapMode2D",
    "projectionPicker",
    "requestRenderMode",
    "maximumRenderTimeChange",
];
var cesiumEventProps$s = {
    onSelectedEntityChange: "selectedEntityChanged",
    onTrackedEntityChange: "trackedEntityChanged",
};
var Viewer = createCesiumComponent({
    name: "Viewer",
    create: function (context, props, wrapper) {
        if (!wrapper)
            return;
        var v = new Viewer$1(wrapper, props);
        if (!v)
            return;
        if (props.imageryProvider === false) {
            v.imageryLayers.removeAll();
        }
        if (v && props.extend) {
            if (Array.isArray(props.extend)) {
                props.extend.forEach(function (e) {
                    v.extend(e, {});
                });
            }
            else {
                v.extend(props.extend, {});
            }
        }
        var state = new EventManager(v.scene);
        return [v, state];
    },
    destroy: function (element, context, ref, state) {
        if (state && !state.isDestroyed()) {
            state.destroy();
        }
        if (!element.isDestroyed()) {
            element.destroy();
        }
    },
    provide: function (element, props, state) {
        var _a;
        return _a = {
                viewer: element,
                cesiumWidget: element.cesiumWidget,
                dataSourceCollection: element.dataSources,
                entityCollection: element.entities,
                scene: element.scene,
                camera: element.scene.camera,
                imageryLayerCollection: element.scene.globe.imageryLayers,
                primitiveCollection: element.scene.primitives,
                globe: element.scene.globe
            },
            _a[eventManagerContextKey] = state,
            _a;
    },
    containerProps: function (_a) {
        var id = _a.id, className = _a.className, style = _a.style, full = _a.full, containerProps = _a.containerProps;
        return (__assign({ className: className,
            id: id, style: __assign(__assign({}, (full
                ? {
                    position: "absolute",
                    bottom: "0",
                    left: "0",
                    right: "0",
                    top: "0",
                }
                : {})), style) }, containerProps));
    },
    cesiumProps: cesiumProps$P,
    cesiumReadonlyProps: cesiumReadonlyProps$d,
    cesiumEventProps: cesiumEventProps$s,
    renderContainer: true,
    useCommonEvent: true,
    useRootEvent: true,
});

var cesiumProps$Q = [
    "positions",
    "maximumHeights",
    "minimumHeights",
    "show",
    "fill",
    "material",
    "outline",
    "outlineColor",
    "outlineWidth",
    "granularity",
    "shadows",
    "distanceDisplayCondition",
];
var cesiumEventProps$t = {
    onDefinitionChange: "definitionChanged",
};
var WallGraphics = createCesiumComponent({
    name: "WallGraphics",
    create: function (context, props) {
        if (!context.entity)
            return;
        var element = new WallGraphics$1(props);
        context.entity.wall = element;
        return element;
    },
    destroy: function (element, context) {
        if (context.entity) {
            context.entity.wall = undefined;
        }
    },
    cesiumProps: cesiumProps$Q,
    cesiumEventProps: cesiumEventProps$t,
});

export { AmbientOcclusion, Billboard, BillboardCollection, BillboardGraphics, BlackAndWhiteStage, Bloom, BlurStage, BoxGraphics, BrightnessStage, Camera, CameraFlyHome, CameraFlyTo, CameraFlyToBoundingSphere, Cesium3DTileset, CesiumContext, CesiumWidget, Clock, Consumer, CorridorGraphics, CustomDataSource, CylinderGraphics, CzmlDataSource, DepthOfFieldStage, EdgeDetectionStage, EllipseGraphics, EllipsoidGraphics, Entity, EntityDescription, EntityStaticDescription, Fog, Fxaa, GeoJsonDataSource, Globe, GroundPrimitive, GroundPrimitiveCollection, ImageryLayer, ImageryLayerCollection, KmlDataSource, Label, LabelCollection, LabelGraphics, LensFlareStage, Model, ModelGraphics, Moon, NightVisionStage, ParticleSystem, PathGraphics, PlaneGraphics, PointGraphics, PointPrimitive, PointPrimitiveCollection, PolygonGraphics, Polyline, PolylineCollection, PolylineGraphics, PolylineVolumeGraphics, PostProcessStage, PostProcessStageComposite, Primitive, Provider, RectangleGraphics, Scene, ScreenSpaceCameraController, ScreenSpaceEvent, ScreenSpaceEventHandler, ShadowMap, SilhouetteStage, SkyAtmosphere, SkyBox, Sun, TimeDynamicPointCloud, Viewer, WallGraphics, createCameraOperation, createCesiumComponent, eventManagerContextKey, eventNames, useCesium, useCesiumComponent, withCesium };
//# sourceMappingURL=resium.es.js.map
